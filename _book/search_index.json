[["index.html", "Practical exercises for Methods in Macroecology and Macroevolution module Modified from the Online Materials to Primer on Phylogenetic Comparative Methods for the Biological Sciences Preface Datasets and scripts How to use these materials Boxes Example datasets Citing R and R packages Acknowledgements", " Practical exercises for Methods in Macroecology and Macroevolution module Modified from the Online Materials to Primer on Phylogenetic Comparative Methods for the Biological Sciences Natalie Cooper Preface The material in this online workbook is designed to be used as practical exercises for my (one week full-time) Masters level module on Methods in Macroecology and Macroevolution. For various reasons this has mostly become a course on phylogenetic comparative methods in R. The exercises are versions of materials I’ve developed over the years, but this most recent iteration was designed to support the Primer on Phylogenetic Comparative Methods for the Biological Sciences by Natalie Cooper and Rob P Freckleton, which is part of the new Oxford Biology Primer series. Primers in Ecology and Evolutionary Biology. In places the materials refer to this Primer. But you won’t need the Primer to run the exercises. The Primer is a work in progress but we are hoping it will be published in 2021/22. This repo is for people who want to use the materials now. As such not all sections are fully completed, for example some references are not included because the papers are still in prep! There will eventually be a nice fully completed version of these materials to go with the Primer! If you spot any errors, issues, mistakes, omissions etc. Please email me (natalie.cooper@nhm.ac.uk) or add an issue to the repo and I’ll try and fix it. All practical exercises use R (R Core Team 2020), so some knowledge of R is required. I have provided the basics in the first chapter. The online workbook focuses on practical implementations of methods for the most part. For information on the theoretical underpinnings of the topics covered here please refer to the lectures and/or Primer. Datasets and scripts All datasets, trees, R scripts (as R Markdown/.Rmd files), and an R Project (.Rproj) file for each exercise are available for download as a ZIP from here. When you click this link it will take you to a website and the download should start automatically. Don’t forget to unzip** this before starting.** The data/trees and scripts are in the appropriate folder for each practical exercise. Note that there is a folder for each of the exercises in the workbook. How to use these materials It is possible to use these materials in a number of ways. Follow this online workbook in a web browser, copy-pasting code into an R script and then running it in the R console. Open the .Rmd (R Markdown) file for each exercise in RStudio and use it as an RNotebook. This allows you to run chunks of code in the script and for the results to appear below the code. You need to open the .Rmd file in folder for that exercise. To run the code, you just click the little green triangles to the far right of each code chunk (grey boxes with R code in them) to run the code as shown below. What a code chunk looks like in an RMarkdown file. The outputs, graphs and results will all appear in the .Rmd file underneath the code, as shown below. After you click the green triangle in the top left hand corner of the code chunk, the code runs and the outputs appear under the code chunk within the RMarkdown file. This is probably the best way to learn these methods. Note, however, that some of the formatting will look a bit weird. For example to get RMarkdown to output the Greek letter lambda we type \\(\\lambda\\). If you want to use these files I’d recommend also opening the online workbook in a web browser so if anything looks odd you can check what it is meant to look like! All the code and outputs are shown in this online workbook, so you can also use this as a reference and then use the code to complete the practical exercises at the end of each chapter, or to apply them to your own data. This might be a good solution if you’re using these materials to learn something specific and don’t need practice with R or PCMs. Boxes Throughout the workbook are boxes of text highlighting particularly important issues: Information boxes. These boxes highlight important details. These boxes may also show you how to solve problems that may not affect every user. Extra details boxes. These boxes contain detailed explanations of things for those who like to fully understand the complexities of what they are doing, for example technical details of the code that I have not explained in detail in the text. Caveats boxes. These boxes highlight important points that need to be considered when working through your own analyses. They reveal areas where it is important to be careful and think about what you are doing and why. The image is a Jurassic Park era velociraptor to remind you of the “Jurassic Park caveat”, i.e. that just because you can perform an analysis in R doesn’t mean that you should (thanks to Dr Ian Malcolm and Dr Michael Crichton)! Always consider the question at hand, your study group, and the quality of the data you are using before embarking on a new comparative analysis. Example datasets I’ve tried to keep my examples to a minimum so that you have chance to get familiar with the trees and data. As such there are just three main example datasets in this workbook. In each case I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to use these datasets for your own work you should download the data from the publications listed to get the complete datasets. Apologies in advance to the non-vertebrate, non-animal fans out there. If it helps just replace the word frog with fly, snake with sponge, and dragonfly with grass. It won’t alter the R code. Frog eye size evolution Frog eyes are really variable. Two tree frogs with large eyes and a burrowing frog and an aquatic frog with tiny eyes. Image credits: hehaden/Flickr CC BY-NC 2.0; Brian Gratwicke/Flickr CC BY 2.0, Rushen/Flickr CC BY-SA 2.0, Sue Cro/Flickr CC BY-NC 2.0 Who doesn’t love frogs? Frogs are cool. One of the coolest things about them is that they have weird bulgy eyes…or do they? Some species have teeny tiny eyes, while others have massive eyes. In fact frogs have some of the biggest eyes relative to their body size across all vertebrates. Thomas et al. (2020) predicted that this variation might be due to where they live, their mating habits, the time of day they are active, and their body size. In our examples we’ll test some of these hypotheses using phylogenetic comparative methods. The data and modified tree for the XX species in this example come from Thomas et al. (2020), and the original tree comes from Feng et al. (2017). If you want to see the full results check out Thomas et al. (2020)! And there’s a nice summary of the paper here. Natricine snake head shape evolution Snakes have different head shapes in different habitats. These are (clockwise starting in the top left) terrestrial/semiaquatic, aquatic, aquatic burrowing, and burrowing natricines. Image credits: Deepak??? Snakes are also cool, especially natricines which are the group that contains both the delightful European grass snake (Natrix natrix) and the ubiquitous garter snakes (genus Thamnophis) of North America. Natricine snakes are found across the globe, and have a range of interesting ecologies and more morphological variation than you might expect, especially in their head shape. Deepak [CITE PAPER] predicted that these variations in head shape would be more closely related to the ecomorph they belonged to (i.e. whether the snake was terrestrial, aquatic, burrowing or aquatic burrowing) than their evolutionary history. They expected that head shape might be an example of convergent evolution. In our examples we’ll test some of these hypotheses using phylogenetic comparative methods. The data for the XX species in this example comes from DEEPAK [CITE PAPER], and the tree comes from DEEPAK [CITE PAPER]. If you want to see the full results check out DEEPAK [CITE PAPER]! And there’s a nice summary of the paper here. Diversification in dragonflies Dragonflies are amazing, this is Aeshna juncea. Image credits: Wikimedia CC BY-SA 3.0 You’ve probably guessed that yes, dragonflies are also cool. They’re incredible predators and extremely agile fliers. My favourite fact about dragonflies is that one species, the globe skimmer (Pantala flavescens) make an annual multi-generational migration of around 18,000km (!) with individual insects flying more than 6,000km (thanks to Dr Jessica Ware for that fact and this dataset!). Dragonflies today are generally found near water, with some preferring lotic habitats with fast flowing waters and others lentic habitats with slow moving waters. The clade has been around for over 300 million years, and currently has over 3000 species. But how quickly did they diversify? Do different clades have different rates of evolution? Do their habitat preferences influence their diversification rates? In our examples we’ll test some of these questions using phylogenetic comparative methods. The 522 species tree for this example comes from Letsch, Gottsberger, and Ware (2016b) and is available to download from Letsch, Gottsberger, and Ware (2016a). This paper looked across dragonflies to investigate whether species from lotic habitats with fast flowing waters diversify more rapidly than species from lentic habitats with slow moving waters. If you want to see the full results check out Letsch, Gottsberger, and Ware (2016b)! Citing R and R packages Lots of people work on R and R packages for free. They’re the reason that R is so great! The best way to thank them for this selfless work is to cite R, and any R packages that you use, whenever you write a report, article, thesis chapter or paper. This means that R developers can show their funders, bosses, supervisors and potential employers that people are using their work. The citation for R will usually look something like this All analyses used R version 4.0 (R Core Team 2020). Your version number might be different (4.0 is the current version at the time of writing this workbook). You only need to do this once, usually in the methods section. The full citation for the bibliography is usually something like: R Core Team (2020). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/. If you don’t remember this, or can’t work out what version of R you are using, the R folk have you covered. To get the citation you can use: citation() ## ## To cite R in publications use: ## ## R Core Team (2020). R: A language and environment for ## statistical computing. R Foundation for Statistical Computing, ## Vienna, Austria. URL https://www.R-project.org/. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {R: A Language and Environment for Statistical Computing}, ## author = {{R Core Team}}, ## organization = {R Foundation for Statistical Computing}, ## address = {Vienna, Austria}, ## year = {2020}, ## url = {https://www.R-project.org/}, ## } ## ## We have invested a lot of time and effort in creating R, please ## cite it when using it for data analysis. See also ## &#39;citation(&quot;pkgname&quot;)&#39; for citing R packages. To get the version of R you can use: R.Version()$version.string ## [1] &quot;R version 4.0.3 (2020-10-10)&quot; You can also look at more version information by running: R.Version() I’ve suppressed the output here as it will be different for every user. The version number is near the bottom of the output. You’ll also see one of the fun things about R here which is that each version has a nickname, all of which are the titles of Peanuts comics! For more info see this slackoverflow discussion. What about R packages? You should cite these at the relevant points in your methods section. For example, for caper(we’ll return to what this does later in the workbook) we might write We fitted phylogenetic generalised least squares (PGLS) models using the R package caper version 1.0.1 (Orme et al. 2018). To find out what the citation is for an R package we also use the function citation but this time specify the package citation(package = &quot;caper&quot;) ## ## To cite package &#39;caper&#39; in publications use: ## ## David Orme, Rob Freckleton, Gavin Thomas, Thomas Petzoldt, ## Susanne Fritz, Nick Isaac and Will Pearse (2018). caper: ## Comparative Analyses of Phylogenetics and Evolution in R. R ## package version 1.0.1. https://CRAN.R-project.org/package=caper ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {caper: Comparative Analyses of Phylogenetics and Evolution in R}, ## author = {David Orme and Rob Freckleton and Gavin Thomas and Thomas Petzoldt and Susanne Fritz and Nick Isaac and Will Pearse}, ## year = {2018}, ## note = {R package version 1.0.1}, ## url = {https://CRAN.R-project.org/package=caper}, ## } ## ## ATTENTION: This citation information has been auto-generated from ## the package DESCRIPTION file and may need manual editing, see ## &#39;help(&quot;citation&quot;)&#39;. Usually package citations contain the version number, but if not you can get the version using packageVersion(&quot;caper&quot;) ## [1] &#39;1.0.1&#39; An additional benefit to citing R packages is that it helps people understand exactly what you did. It’s possible there are multiple ways to run a PGLS model, but if your report says you used caper, it’s easy for a reader to check how caper does it and to know exactly what you did. This helps people reproduce your analysis, and can also help you prove to anyone assessing your work that you know what you are doing! Acknowledgements Thanks to the many generations of students who have taken courses with me and helped me to hone these materials. And to the many others out there teaching PCMs and writing tutorials that helped me learn these methods in the first place, especially Luke Harmon, Brian O’Meara, Dave Orme, Sam Price, Dan Rabosky, Liam Revell and Graham Slater. Also thanks to you for test running this version of these materials. Particular thanks to the authors of the R packages used and cited in this workbook. None of this would be possible without them. Do not forget to cite the packages you use in your own work. And if you meet one of the package authors in person, buy them a beer/cake/coffee to say thank you! Best of luck to you all, and happy PCM-ing! References "],["what-you-need-to-be-able-to-do-in-r-before-you-start.html", "Chapter 1 What you need to be able to do in R before you start 1.1 Installing R (and RStudio) 1.2 Downloading the data 1.3 R Projects 1.4 Using a script 1.5 Installing and loading extra packages in R 1.6 Loading and viewing your data in R 1.7 Errors and warnings 1.8 Summary", " Chapter 1 What you need to be able to do in R before you start These days most people have used R a bit, but it is possible you’re a bit rusty, or have no R experience. This isn’t a problem, I will try and summarise what you need to be able to do to get these exercises running below. I am not, however, going to write a full introductory guide to R here, so if you’ve never used R before or find it a bit of a struggle, I strongly recommend the book Getting Started With R or there are lots of great tutorials online. Throughout, R code will be in shaded boxes: library(ape) R output will be preceded by ## and important comments will be in quote blocks: Note that many things in R can be done in multiple ways. You should choose the methods you feel most comfortable with. Don’t panic if I do it differently! 1.1 Installing R (and RStudio) Install R from https://cran.r-project.org You can install RStudio (Desktop) from http://www.rstudio.com/products/rstudio/download/. I highly recommend using RStudio and I will assume you are using it throughout. RStudio is just a wrapper around R, so you still need to install R to use RStudio. If using a Mac, you should also install XQuartz: https://www.xquartz.org/ 1.2 Downloading the data As mentioned in the Preface, the data/trees and an R Project (.Rproj) file for each exercise are in the appropriate folder for each practical exercise. To work through the exercises you need to download all the files into a folder somewhere on your computer. Don’t forget to unzip this before starting. Note that there is a folder for each of the exercises in the book. Some datasets are built into R and/or various R packages (see below), so you may see me access these just using code like this (cars is a dataset built into R): data(cars) Note that this won’t produce any output unless we then ask it to do something with the data, for example print the first six rows… head(cars) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 ## 5 8 16 ## 6 9 10 1.3 R Projects One feature of R that tends to trip up beginners is that to read data into R you need to tell R where to look for the data. In the past we might have solved this problem by setting the working directory, or writing the full path to a file into our code. This works fine, but if you later move the folder or the data, or send it to a collaborator/supervisor the code stops working. Luckily RStudio has a great solution to the problem: R Projects. If you’re working in an R Project, R will automatically look for data in the folder you’ve chosen to be the project folder! What’s a Project? A “Project” is just a folder that contains a sensible unit of work, for example your undergraduate or masters thesis, a chapter of your PhD thesis, a paper, or a coursework project. Projects will likely contain several files, including data and R scripts. You may also want to store information related to the report/thesis chapter/coursework that you’re writing. To make an R Project for practical exercises in 05-PGLSinR, for example, go to the menu in RStudio and click File &gt; New Project. You should now see a dialogue box with three options: New Directory, Existing Directory, or Version Control (Directory just means a folder on your computer). Because we already have a folder choose the option Existing Directory. The dialogue box moves on so we can use the Browse button to locate the folder 05-PGLSinR. Finally, click the Create Project button. This will cause a few things to happen. First, RStudio may ask if you want to save any unsaved files if you were already doing something in RStudio. Save them if they are important! Second, RStudio will look like it restarted. And third, a new file will appear in the folder: the .Rproj file, with the same file name as your R Project. When you want to use that R Project in future just double click the .Rproj icon in the folder and it will open the R Project in RStudio for you. To save you some time we have made an .Rproj file for each chapter of this book. They should have been downloaded with the data. To use these just navigate to the appropriate chapter folder and double click the .Rproj icon to start. 1.4 Using a script We can use R straight from the Console (the bottom left hand window in a standard RStudio set up), but this is not ideal for various reasons. Firstly, if we want to run a series of separate commands, and perhaps run them again in the future, or alter one of the commands thus needing to re-run all the subsequent ones, then typing commands into the Console is a pain. Equally we might want to save our commands for future use. To do this we use a script. To get a new script in RStudio use the menus to go from File &gt; New File &gt; R Script. You should type (or copy and paste) your code into the script, edit it until you think it’ll work, and then either paste it into R’s console window, or you can highlight the bit of code you want to run and press ctrl or cmd and enter or R (different computers seem to do this differently). This will automatically send it to the console. Saving the script file lets you keep a record of the code you used, which can be a great time saver if you want to use it again, especially as you know this code will work! You can cut and paste code from these materials into your script. You don’t need to retype everything! If you want to add comments to the file (i.e., notes to remind yourself what the code is doing), put a hash/pound sign (#) in front of the comment. Comments are really important to you remember what you did and why. Always write comments, and generally write more than you think you will need. Future you will thank past you when you need to rerun these analyses in six months! # Comments are ignored by R but remind you what the code is doing. # You need a # at the start of each line of a comment. # Always make plenty of notes to help you remember what you did and why 1.5 Installing and loading extra packages in R You’ll notice at the start of each exercise we remind you of the packages you need to install and load. To run any specialised analysis in R, you need to download one or more additional packages on top of the basic R installation. You need to be connected to the internet to do this. To install the package ape: install.packages(&quot;ape&quot;) Pick the closest mirror to you if asked. Do not put this code into your script as you only need to do this once (until you need to update R), and it’s a waste of your time to do it each time you run your script. You can also install more than one package at a time: install.packages(c(&quot;ape&quot;, &quot;picante&quot;)) Alternatively, you can use the Packages tab in RStudio (in the bottom left hand window in a standard RStudio set up). If you click the Install button this will open a pop up where you can type in a list of the packages you want to install, and then just click Install. If you do this, you’ll see the appropriate install.packages code appear in your console. If everything worked you will see some (often a lot if you’re installing a big package like tidyverse or ggtree) text appearing in the console, and the occasional warning message but importantly no error messages. Don’t let this worry you. If you’re in doubt about whether a package has installed correctly, go to the next step (see Loading packages into R below) to check. If you see an error message (these will contain the prefaceError:, see section below on Errors and warnings for more details), then something, somewhere has gone wrong. Installation errors will generally say something about non-zero exit status of the package, which just tells you that it was not installed. You might need to scroll up a bit to find this. Some common issues that might arise when installing packages are: R asks if you would like to update other packages that the package you are installing needs to work. You might see the question Update all/some/none? [a/s/n]:. In that case type a and press enter, and R will update these packages too. R asks if you Do you want to install from sources the packages which need compilation? (Yes/no/cancel) or similar. In this case, type Yes or y or whatever the suggested option is for yes. However if this doesn’t work and the installation gives you an error, try installing again and this time choose the option for no. Some packages will need to be compiled from source. If you’re using a Mac you may also need to install clang from this page https://cran.r-project.org/bin/macosx/tools/ before this will work. An annoying error you may encounter (generally on a Mac), is that you keep seeing error messages when trying to install some packages, even after trying the solutions above. This might be because you’re installing via the RStudio default server for packages. To fix this, change your default by going to RStudio &gt; Preferences &gt; Packages. You should see a box with CRAN mirror above it. Change this from Global (CDN) RStudio to your closest mirror on the list and click Apply. This should fix the problem and only needs to be done once. Note that this issue may be fixed soon by RStudio, but has been an issue in the current version. If you see non-zero exit status and the name of a package you weren’t trying to install, it just means that this package is needed for the package you are trying to install to work. In these cases, try installing that package, then if that works try again with the package you wanted to try and install. If it still won’t work, it’s also worth trying to install packages both in RStudio, and just in the normal version of R you downloaded. For this there is no Packages tab so you need to use install.packages. If you get other kinds of errors don’t panic. Check you are connected to the internet. Read the error message carefully to see if it gives you any clues. If that fails, try pasting the error message into Google and seeing if anyone else has had the same error. 1.5.1 Loading packages into R You’ve installed the packages but they don’t automatically get loaded into your R session. Instead you need to tell R to load them every time you start a new R session and want to use functions from these packages. To load the package ape into your current R session: library(ape) You can think of install.packages like installing an app from the App Store on your smart phone - you only do this once - and library as being like pushing the app button on your phone - you do this every time you want to use the app (credit to Dylan Childs for this great analogy!). For many packages, you won’t see any message at all when you run library(package_name). That means the code has worked. Some packages will print a message explaining some feature of the package, or telling you that it is also loading some other package, or highlighting that the package was written for a newer version of R. As long as you don’t see an error message, everything is fine. If you run library(package_name) and you get the error message Error in library(package_name) : there is no package called ‘package_name’package not found, this means you have not installed the package properly. Often just going back and trying to install it again will work. Or check out the list of possible solutions above. 1.5.2 ggtree, a special case for package installation Packages are generally installed from CRAN, the same place you downloaded R from. But some communities share their packages in different ways. ggtree is one such package. To install ggtree we need to use Bioconductor instead as follows: if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;ggtree&quot;) You still need to load it using library as usual. Note that ggtree will produce a long message when you first load it telling you how to cite the package, and some functions it contains with the same names as functions in other packages (I’ve supressed this here). library(ggtree) 1.6 Loading and viewing your data in R R can read files in lots of formats, but for simplicity we’ll use comma-delimited or .csv files in these exercises. Excel (and many other applications) can output files in this format (it’s an option in the Save As dialogue box under the File menu). As an example, here is how you would read in a comma-delimited text file called Primatedata.csv using the readr package: library(readr) primatedata &lt;- read_csv(&quot;Primatedata.csv&quot;) This is a good point to note that unless you tell R you want to do something, it won’t do it automatically. So here if you successfully entered the data, R won’t give you any indication that it worked. Instead you need to specifically ask R to look at the data. We can look at the data by typing: str(primatedata) Or if we are using the tidyverse packages library(tidyverse) glimpse(primatedata) I’ve suppressed the output here to keep things simple. Always look at your data before beginning any analysis to check it read in correctly. We will cover this in more detail in later sections. 1.7 Errors and warnings Errors are where the code fails to run and you see an error message prefaced in R by Error:. Often these mistakes are caused by typos, missing commas, or missing brackets. R is very pedantic so this happens a lot! But they can also be caused by applying functions incorrectly or to the wrong kinds of data. Error messages are sometimes helpful, but often pretty baffling especially for beginners. If you get an error message don’t panic. Read the message and see if you can work out what the issue is. Check your code carefully for typos. Make sure you’re using the correct data and variable names etc. If you can’t work out what the error means, try Googling it (remove any words specific to your data from it first). Google may be able to tell you what the issue is. If that still doesn’t help, try asking colleagues or post a question online. The important thing about errors is that the code does not run. Warnings, on the other hand, appear when the code runs fine, but R wants to alert us to something, for example that the code might not be doing what you intended, or R has recognised that something you asked it to do is a bit risky. Do not ignore warning messages!. Always read the warning message and try to understand what it means. You may figure out that you can safely ignore the warning (we will try and note these situations in the exercises here). Otherwise you probably need to try and fix it. 1.7.1 Removing the + Some R functions are pretty long, meaning that they need to appear on more than one line in the Console. In a long function, you therefore see a + in front of all lines except the first one. This tells you that R is running the code together. Unfortunately, if you accidentally fail to finish a line of code (for example by not closing \" or brackets), R will assume you haven’t finished and will add a + on the next line. If that wasn’t your intention, and you try to run another bit of code on the next line, then that next line of code won’t work leading to an error. Don’t worry, this happens all the time! If you’re getting error messages and can’t see why, just check that the Console is showing the prompt &gt; not the + at the start of your line of code. If you see the +, just hit the Escape key to get back to the prompt &gt; and then go back to your code. 1.8 Summary This covers the main introductory elements of R and means you should be able to run the code in the exercises. "],["diversity-indices-in-r.html", "Chapter 2 Diversity Indices in R 2.1 Before you start 2.2 Preparation 2.3 What are diversity indices? 2.4 Practical example using Pokemon… 2.5 Species diversity indices 2.6 Species accumulation curves (Colwell &amp; Coddington 1994) 2.7 Practical exercise", " Chapter 2 Diversity Indices in R The aims of this exercise are to learn how to use R to estimate diversity indices and species accumulation curves. You will need some of these functions to complete your paleoecology assessment. We will be using some made up data about Pokemon sightings within the Museum. 2.1 Before you start Open the 02-DiversityIndices.RProj file in the 02-DiversityIndices folder to open your R Project for this exercise. Make yourself a new R script for your code. You will also need to install the following packages: vegan picante knitr 2.2 Preparation To begin we need to load the packages for this practical. # Load the packages library(vegan) library(picante) library(knitr) 2.3 What are diversity indices? A diversity index is a measure of the “diversity” of an area. Diversity could be measured in terms of the numbers of species (or higher taxonomic groupings like genera, families, phyla), or other metrics such as number of haplotypes if you’re interested in genetic diversity, or number of functional groups for studies of functional diversity. Many diversity indices also account for how evenly spread these different types are. For example, they identify whether there are there five species with 10 individuals of each (even), or five species with one species with 96 individuals and four species with one individual each (uneven). These differences in evenness may be as important for ecosystem function as the number of species. There are about a million different diversity indices (OK this is a slight exaggeration but there are a lot, check out the vegan package vignette and search for “diversity”), and different people prefer different measures for different questions. Amusingly the vegan help file for the function diversify states “these indices are all very closely related Hill (1973), and there is no reason to despise one more than others (but if you are a graduate student, don’t drag me in, but obey your Professor’s orders)”. 2.3.1 \\(\\alpha\\), \\(\\beta\\) and \\(\\gamma\\) diversity These concepts were originally proposed by Whittaker (1960) and expanded in Whittaker (1972). \\(\\alpha\\) (alpha) diversity is the mean species diversity in sites or habitats at a local scale. \\(\\beta\\) (beta) diversity is turnover in \\(\\alpha\\) diversity among different sites. \\(\\gamma\\) (gamma) diversity is diversity at the landscape level. For example, if we count the species in Hyde Park and Green Park, we’d have a measure of \\(\\alpha\\) diversity for each. \\(\\beta\\) diversity would measure the difference between species found in Hyde Park and those found in Green Park. \\(\\gamma\\) diversity would be all the species found across London. \\(\\beta\\) diversity is the hardest to measure, and there are far more metrics for measuring this than any others. 2.4 Practical example using Pokemon… We’re going to play around with some invented data on sampling sites within the Museum and the Pokemon we’ve managed to find there (don’t complain about my unlikely Pokemon combinations, they’re just made up data with Pokemon names rather than A, B, C etc!). Who doesn’t love a practical handout being interrupted by an enormous Pikachu? First read in the data and take a look at it. # Read in the dataset pokemon &lt;- read.csv(&quot;data/pokemon-communities.csv&quot;) # Look at the data # I used kable from the knitr package so it makes a nice neat table kable(pokemon) Site Abundance Species site01 5 Bulbasaur site01 3 Charmander site02 6 Pidgey site02 6 Rattata site02 1 Spearow site03 1 Bulbasaur site03 1 Charmander site03 1 Pidgey site03 10 Rattata site03 1 Spearow site03 1 Pikachu site04 1 Pikachu site04 2 Charmander site05 3 Squirtle site05 2 Caterpie site05 4 Pidgey site05 3 Rattata site06 1 Psyduck site07 3 Bulbasaur site07 3 Charmander site07 3 Squirtle site07 3 Caterpie site07 3 Pidgey site07 3 Rattata site07 3 Spearow site08 5 Bulbasaur site08 5 Caterpie site09 10 Squirtle site10 3 Pidgey site10 6 Charmander site10 2 Zubat For the vegan functions to work you need a matrix where the columns are the species names, the rows are the communities, and the contents of the matrix are the numbers of each species found at each site (or presence absence data as 0s and 1s). We can use the sample2matrix function in picante to do this easily. Note that this only works if your first variable is the name of the site, your second is abundance and your third is the names of the species present. # Create a matrix we can use with vegan pokemon.matrix &lt;- sample2matrix(pokemon) # Look at the matrix kable(pokemon.matrix) Bulbasaur Caterpie Charmander Pidgey Pikachu Psyduck Rattata Spearow Squirtle Zubat site01 5 0 3 0 0 0 0 0 0 0 site02 0 0 0 6 0 0 6 1 0 0 site03 1 0 1 1 1 0 10 1 0 0 site04 0 0 2 0 1 0 0 0 0 0 site05 0 2 0 4 0 0 3 0 3 0 site06 0 0 0 0 0 1 0 0 0 0 site07 3 3 3 3 0 0 3 3 3 0 site08 5 5 0 0 0 0 0 0 0 0 site09 0 0 0 0 0 0 0 0 10 0 site10 0 0 6 3 0 0 0 0 0 2 2.5 Species diversity indices 2.5.1 \\(\\alpha\\) diversity The simplest measure of \\(\\alpha\\) diversity is just the number of species in each site. You can easily extract this as follows. specnumber(pokemon.matrix) ## site01 site02 site03 site04 site05 site06 site07 site08 site09 site10 ## 2 3 6 2 4 1 7 2 1 3 Simpson’s and Shannon’s diversity indices can be estimated using the function diversity. # Simpson&#39;s index diversity(pokemon.matrix, index = &quot;simpson&quot;) ## site01 site02 site03 site04 site05 site06 site07 ## 0.4687500 0.5680473 0.5333333 0.4444444 0.7361111 0.0000000 0.8571429 ## site08 site09 site10 ## 0.5000000 0.0000000 0.5950413 # Shannon&#39;s index diversity(pokemon.matrix, index = &quot;shannon&quot;) ## site01 site02 site03 site04 site05 site06 site07 ## 0.6615632 0.9110175 1.1729935 0.6365142 1.3579779 0.0000000 1.9459101 ## site08 site09 site10 ## 0.6931472 0.0000000 0.9949236 2.5.2 \\(\\beta\\) diversity The function betadiver allows you to estimate all the \\(\\beta\\) diversity indices mentioned in Koleff, Gaston, and Lennon (2003). For help on which indices are included type: betadiver(help=TRUE) ## 1 &quot;w&quot; = (b+c)/(2*a+b+c) ## 2 &quot;-1&quot; = (b+c)/(2*a+b+c) ## 3 &quot;c&quot; = (b+c)/2 ## 4 &quot;wb&quot; = b+c ## 5 &quot;r&quot; = 2*b*c/((a+b+c)^2-2*b*c) ## 6 &quot;I&quot; = log(2*a+b+c) - 2*a*log(2)/(2*a+b+c) - ((a+b)*log(a+b) + ## (a+c)*log(a+c)) / (2*a+b+c) ## 7 &quot;e&quot; = exp(log(2*a+b+c) - 2*a*log(2)/(2*a+b+c) - ((a+b)*log(a+b) ## + (a+c)*log(a+c)) / (2*a+b+c))-1 ## 8 &quot;t&quot; = (b+c)/(2*a+b+c) ## 9 &quot;me&quot; = (b+c)/(2*a+b+c) ## 10 &quot;j&quot; = a/(a+b+c) ## 11 &quot;sor&quot; = 2*a/(2*a+b+c) ## 12 &quot;m&quot; = (2*a+b+c)*(b+c)/(a+b+c) ## 13 &quot;-2&quot; = pmin(b,c)/(pmax(b,c)+a) ## 14 &quot;co&quot; = (a*c+a*b+2*b*c)/(2*(a+b)*(a+c)) ## 15 &quot;cc&quot; = (b+c)/(a+b+c) ## 16 &quot;g&quot; = (b+c)/(a+b+c) ## 17 &quot;-3&quot; = pmin(b,c)/(a+b+c) ## 18 &quot;l&quot; = (b+c)/2 ## 19 &quot;19&quot; = 2*(b*c+1)/(a+b+c)/(a+b+c-1) ## 20 &quot;hk&quot; = (b+c)/(2*a+b+c) ## 21 &quot;rlb&quot; = a/(a+c) ## 22 &quot;sim&quot; = pmin(b,c)/(pmin(b,c)+a) ## 23 &quot;gl&quot; = 2*abs(b-c)/(2*a+b+c) ## 24 &quot;z&quot; = (log(2)-log(2*a+b+c)+log(a+b+c))/log(2) Note that some of these are similarity indices, and some are dissimilarity indices. See Koleff, Gaston, and Lennon (2003) for more details. Two commonly used similarity indices are Jaccard’s index and Sorenson’s index which can be estimated as follows (note that completely different communities get a score of 0): # Jaccard&#39;s index betadiver(pokemon.matrix, method = &quot;j&quot;) ## site01 site02 site03 site04 site05 site06 ## site02 0.0000000 ## site03 0.3333333 0.5000000 ## site04 0.3333333 0.0000000 0.3333333 ## site05 0.0000000 0.4000000 0.2500000 0.0000000 ## site06 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## site07 0.2857143 0.4285714 0.6250000 0.1250000 0.5714286 0.0000000 ## site08 0.3333333 0.0000000 0.1428571 0.0000000 0.2000000 0.0000000 ## site09 0.0000000 0.0000000 0.0000000 0.0000000 0.2500000 0.0000000 ## site10 0.2500000 0.2000000 0.2857143 0.2500000 0.1666667 0.0000000 ## site07 site08 site09 ## site02 ## site03 ## site04 ## site05 ## site06 ## site07 ## site08 0.2857143 ## site09 0.1428571 0.0000000 ## site10 0.2500000 0.0000000 0.0000000 # Shannon&#39;s index betadiver(pokemon.matrix, method = &quot;sor&quot;) ## site01 site02 site03 site04 site05 site06 ## site02 0.0000000 ## site03 0.5000000 0.6666667 ## site04 0.5000000 0.0000000 0.5000000 ## site05 0.0000000 0.5714286 0.4000000 0.0000000 ## site06 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## site07 0.4444444 0.6000000 0.7692308 0.2222222 0.7272727 0.0000000 ## site08 0.5000000 0.0000000 0.2500000 0.0000000 0.3333333 0.0000000 ## site09 0.0000000 0.0000000 0.0000000 0.0000000 0.4000000 0.0000000 ## site10 0.4000000 0.3333333 0.4444444 0.4000000 0.2857143 0.0000000 ## site07 site08 site09 ## site02 ## site03 ## site04 ## site05 ## site06 ## site07 ## site08 0.4444444 ## site09 0.2500000 0.0000000 ## site10 0.4000000 0.0000000 0.0000000 Note that the outputs here are pairwise matrices, as these indices measure the similarity among each pair of sites. You can estimate Whittaker’s original version using method = \"w\" (this is a dissimilarity method so completely different communities get a score of 1). # Whittaker&#39;s betadiversity index betadiver(pokemon.matrix, method = &quot;w&quot;) ## site01 site02 site03 site04 site05 site06 ## site02 1.0000000 ## site03 0.5000000 0.3333333 ## site04 0.5000000 1.0000000 0.5000000 ## site05 1.0000000 0.4285714 0.6000000 1.0000000 ## site06 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 ## site07 0.5555556 0.4000000 0.2307692 0.7777778 0.2727273 1.0000000 ## site08 0.5000000 1.0000000 0.7500000 1.0000000 0.6666667 1.0000000 ## site09 1.0000000 1.0000000 1.0000000 1.0000000 0.6000000 1.0000000 ## site10 0.6000000 0.6666667 0.5555556 0.6000000 0.7142857 1.0000000 ## site07 site08 site09 ## site02 ## site03 ## site04 ## site05 ## site06 ## site07 ## site08 0.5555556 ## site09 0.7500000 1.0000000 ## site10 0.6000000 1.0000000 1.0000000 2.5.3 \\(\\gamma\\) diversity In this example, \\(\\gamma\\) diversity is the total number of species found across all sites. We can very simply calculate this in R using the following code: # How many unique species are there? length(unique(pokemon$Species[pokemon$Abundance &gt; 0])) ## [1] 10 # To view unique species unique(pokemon$Species) ## [1] &quot;Bulbasaur&quot; &quot;Charmander&quot; &quot;Pidgey&quot; &quot;Rattata&quot; &quot;Spearow&quot; ## [6] &quot;Pikachu&quot; &quot;Squirtle&quot; &quot;Caterpie&quot; &quot;Psyduck&quot; &quot;Zubat&quot; Note that the [pokemon$Abundance &gt; 0] bit of the code ensures we don’t count species where we have them in the species list, but their abundance at all sites is zero. 2.6 Species accumulation curves (Colwell &amp; Coddington 1994) Often when we talk about species diversity we’re interested in the total diversity of an area or a site. For example, if we want to conserve a patch of woodland, we might need to know how many species in total live there. Sounds easy enough right? Just go out and sample the heck out of that woodland… The problem of course is that sampling is time consuming and expensive, and in conservation we don’t have much time or money. In addition, completely sampling all species in an area is difficult, especially for small, rare, shy species. Instead we often estimate species richness by various means. Species accumulation curves are one way to do this. Species accumulation curves are graphs showing the cumulative number of species recorded in an area or site as a function of the cumulative sampling effort taken to search for them. Sampling effort can be number of quadrats, number of hours of sampling etc. for \\(\\alpha\\) diversity, or number of sites if trying to get an estimate of \\(\\gamma\\) diversity. The idea is that as you sample more, you should get closer to discovering all the species in the area. The first few samples you take will probably have lots of species you haven’t recorded yet, but this rate of discovery should slow down. Eventually you hope that you’ll stop finding any new species to record so the curve will asymptote, but in reality sampling is rarely that thorough. Luckily we can use species accumulation curves to estimate where the curve would asymptote if we kept on sampling. 2.6.1 Pokemon species accumulation curves Let’s try this for our Pokemon, how many species might be hiding in the Museum if we sampled thoroughly? We can use the pokemon.matrix we’ve already created and estimate the accumulation curve using the vegan function specaccum. There are lots of methods for estimating these curves but we will use method = \"random\". This works as follows. It randomly selects a site and calculates the initial richness, then randomly selects a second site and calculates the cumulative richness (i.e. the second site plus the first site), and repeats this until all the sites have been used. It then repeats this process 1000 times. You can change the number of times it does this using permutations but 1000 is about right - too few and the curves are not smooth, too many and it takes ages. The function outputs the mean cumulative richness and standard deviations for across all 1000 permutations. We do this because our curve will look different depending on which site we start with, and so will give a different total richness estimate. Randomising the order helps us get a better estimate of the total richness, and the standard error on that estimate. To do this for our Pokemon: # Fit species accumulation curve pokemon.curve &lt;- specaccum(pokemon.matrix, method = &quot;random&quot;, permutations = 1000) # Look at the results pokemon.curve ## Species Accumulation Curve ## Accumulation method: random, with 1000 permutations ## Call: specaccum(comm = pokemon.matrix, method = &quot;random&quot;, permutations = 1000) ## ## ## Sites 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 ## Richness 3.016000 5.155000 6.654000 7.707000 8.422000 8.927000 9.288000 ## sd 1.866341 1.696424 1.302298 0.920869 0.743282 0.685668 0.627255 ## ## Sites 8.000000 9.000000 10 ## Richness 9.563000 9.785000 10 ## sd 0.531332 0.411028 0 # Plot the curve plot(pokemon.curve, ci.type = &quot;poly&quot;, col = &quot;blue&quot;, ci.col = &quot;lightblue&quot;, lwd = 2, ci.lty = 0, xlab = &quot;number of sites&quot;, ylab = &quot;cumulative number of Pokemon species&quot;) \"ci.type = \"poly\" tells R that you want a shaded area showing the confidence intervals from your randomisations. You can play around with the colours etc. if you want to. For those of you who prefer to use ggplot, we can plot these curves as follows. Note that because ggplot works with dataframes we first need to create a dataframe from the pokemon.curve object. Also we use standard deviation * 1.96 to get the confidence intervals. # Load ggplot library(ggplot2) # Make a new dataframe pokemon.curve.df &lt;- data.frame(sites = pokemon.curve$sites, richness = pokemon.curve$richness, sd = pokemon.curve$sd) # Plot ggplot(pokemon.curve.df, aes(x = sites, y = richness)) + # Add line geom_line() + # Add confidence intervals geom_ribbon(aes(ymin = richness - 1.96*sd, ymax = richness + 1.96*sd), alpha = 0.5, colour = &quot;grey&quot;) + # Remove grey background theme_bw(base_size = 14) To demonstrate why we need the randomisations, look at two curves for just one permutation each. # Fit one curve with just one permutation pokemon.curve1 &lt;- specaccum(pokemon.matrix, method = &quot;random&quot;, permutations = 1) # Fit another curve with just one permutation pokemon.curve2 &lt;- specaccum(pokemon.matrix, method = &quot;random&quot;, permutations = 1) # Set the plotting window so we can plot two plots par(mfrow = c(1,2)) # Plot the first curve plot(pokemon.curve1, xlab = &quot;number of sites&quot;, ylab = &quot;cumulative number of Pokemon species&quot;) # Plot the second curve plot(pokemon.curve2, xlab = &quot;number of sites&quot;, ylab = &quot;cumulative number of Pokemon species&quot;) # Reset the plotting window so we see just one plot again par(mfrow = c(1,1)) Finally to estimate total species richness across all sites we can (again) use many different metrics. Some common ones include Chao 2 (Chao 1987), Jackknife and Bootstrapping approaches and these are easy to estimate using the vegan function specpool. # Estimate diversity specpool(pokemon.matrix) ## Species chao chao.se jack1 jack1.se jack2 boot boot.se n ## All 10 11.8 3.394113 11.8 1.272792 12.68889 10.90352 0.7502033 10 Estimates range from 10.9 \\(\\pm\\) 0.75 (boot) to 11.8 \\(\\pm\\) 3.39 (chao). So we can be fairly confident there are between 10 and 15 (\\(11.8 + 3.39 = 15.19\\)) Pokemon in the Museum. 2.7 Practical exercise In the data folder there is another (invented) dataset using British bats called bat-communities.csv. Read in the data, manipulate it as required by vegan, then answer the following questions. Which site has the fewest species? How many different species are there in total? What is Simpson’s diversity index for Site J? Draw a species accumulation curve for the bats and estimate the total number of species. If you round up numbers with decimal places, what is the maximum number of species estimated by any metric? References "],["understanding-plotting-and-manipulating-phylogenies-in-r.html", "Chapter 3 Understanding, plotting and manipulating phylogenies in R 3.1 Before you start 3.2 What do phylogeny files look like? 3.3 How are phylogenies formatted in R? 3.4 Plotting phylogenies 3.5 Phylogeny manipulation 3.6 Summary 3.7 Practical exercise", " Chapter 3 Understanding, plotting and manipulating phylogenies in R Using phylogenies in R can feel daunting at first, even if you’re already familiar with R. Luckily, lots of nice R packages exist to help us work with them, and fairly new packages like ggtree mean we can now make beautiful phylogeny plots without needing to resort to other software. In this chapter I’ll introduce you to how R stores phylogenies, and then show you how to plot them and manipulate them before using them in your PCMs. Most of the examples come from the Primer. 3.1 Before you start Open the 03-Phylogenies.RProj file in the 03-Phylogenies folder to open your R Project for this exercise. Make yourself a new R script for your code. You will also need to install the following packages: ape tidyverse ggtree patchwork ggimage phytools 3.2 What do phylogeny files look like? There are many different formats that you might get a phylogeny in, but the most common formats of the tree files we read into R are Newick and NEXUS. Here we will just focus on these two. If you need to read in lots of different kinds of tree files check out the documentation for ggtree. 3.2.1 Newick trees Newick (or New Hampshire) format uses brackets/parentheses to group taxa together with their closest relatives. Tips are represented by their names, and these names can include any characters except blanks, colons, semicolons, parentheses, and square brackets. Because blanks are not allowed, we use underscores to replace them, meaning that in many phylogenies the tip names are formatted as Genus_species. Our basic tree from the Primer is shown below. The topology of this tree can be represented in Newick format as: (((robin,deer),spider),jellyfish); Note that Newick trees always end with a semicolon. Branch lengths can be added into a tree by adding a colon followed by the branch length after the node. This represents the length of the branch immediately following that node, so numbers after a tip label show how long the branches at the tips of the tree are, and others show how long the internal branches are. For our tree above this can be written as: (((robin:4.2,deer:4.2):3.1,spider:7.3):6.3,jellyfish:13.5); And that is basically all there is to Newick trees! In R these can be read in using read.tree from the APE package. They are usually stored in .tre or .phy files. 3.2.2 NEXUS trees NEXUS files are a little more complicated, but are also based on the Newick format. Many tree inference packages will output trees as NEXUS files, so they are very commonly used in R. You read them in using read.nexus from the APE package, and they are usually stored in .nex files. A NEXUS file for the tree above might look like the example below. First it uses the #NEXUS tag to tell the computer it is a NEXUS file, then the first block lists how many taxa there are (NTAX) and then what the names of the taxa are (TAXLABELS), i.e. the tip labels. Then the second block first gives each taxon a number, then the TREE block shows the tree in Newick format, exactly as we did above except using the numbers for the taxa rather than their names. The UNTITLED = [&amp;R] part just means we haven’t given the tree a name, and that the tree is rooted. #NEXUS BEGIN TAXA; DIMENSIONS NTAX = 4; TAXLABELS robin deer spider jellyfish ; END; BEGIN TREES; TRANSLATE 1 robin, 2 deer, 3 spider, 4 jellyfish ; TREE * UNTITLED = [&amp;R] (((1:4.2,2:4.2):3.1,3:7.3):6.3,4:13.5); END; NEXUS files can be much more complex and include the data used to infer the tree too, but we don’t need this for comparative analyses so read.nexus will just ignore it. Sometimes someone will email you a .tre or .nex file, or you’ll download one from the internet, but when you use read.tre or read.nexus it just keeps giving you an error. Before panicking, check what you did after you downloaded the tree file. Did you open it to take a look? On some computers, doing this makes the computer freak out because it doesn’t know what to do with .tre or .nex files, so it converts them into something it does understand like .txt or .docx. This then alters the tree file to the point that R can no longer read it. To solve the problem, just download the file again but this time don’t open it!. Just save it and then read it into R. If you need to look at one of these files outside of R, try “Open with” and pick a text editor like Notepad or TextEdit. This shouldn’t alter the file. 3.3 How are phylogenies formatted in R? You don’t need to know how phylogenies are represented in R to use them, but it helps to have a bit of an idea what is going on. To load a tree into R you need either the function read.tree or read.nexus from the package APE. read.tree can deal with a number of different types of data (including DNA) whereas read.nexus reads NEXUS files. Let’s practice with our basic tree from the Primer. We can read it in using read.tree. Remember to load the APE library first or this won’t work. # Load ape library(ape) # Read in the tree tree &lt;- read.tree(&quot;data/basic.tre&quot;) Note that whether we read the tree in using read.tree or read.nexus the resulting tree in R is the same. To understand what is going on we need a bit of computer programming jargon. Phylogenies are stored as objects of class phylo. What do I mean by this? Whenever we make a new “thing” in R and save it with a name we have created an object. So the code tree &lt;- read.tree(\"data/basic.tre\") above makes a new object called tree which will have the phylogeny stored in it. Each object in R belongs to a class, which is a sort of blueprint for how the object should behave. For example, objects of numeric class will behave differently to objects of character class - we can’t multiply two characters (i.e. words) together but we can multiply two numbers. There are many classes in R and each have different rules. The phylo class is one of these that we use for phylogenies. Let’s examine the tree by typing: # Look at the tree summary tree ## ## Phylogenetic tree with 4 tips and 3 internal nodes. ## ## Tip labels: ## robin, deer, spider, jellyfish ## ## Rooted; includes branch lengths. Notice that when we print out a phylo object like tree, it doesn’t just give us all of the information in the tree file. Instead it gives us a couple of bits of summary information. It tells us how many tips (4) and internal nodes (3) the tree has, then lists the tip labels. It also tells us the tree is rooted and contains branch lengths. If we want to look more closely at the components that make up a phylo object we need to look at the structure of tree using str. # Look at the summary of tree components str(tree) ## List of 4 ## $ edge : int [1:6, 1:2] 5 6 7 7 6 5 6 7 1 2 ... ## $ edge.length: num [1:6] 6.3 3.1 4.2 4.2 7.3 13.5 ## $ Nnode : int 3 ## $ tip.label : chr [1:4] &quot;robin&quot; &quot;deer&quot; &quot;spider&quot; &quot;jellyfish&quot; ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; This gives us a bit more information about what is going on. tree contains four variables: edge shows how the branches and tips are linked together (I’ll show you how this works below). edge.length gives the branch lengths. Nnode tells you how many internal nodes there are. tip.label is a list of the taxon names. If we want to see the whole of the phylo object we have to use a little trick. Everything we do to tree at the moment will work based on tree being a phylo object. If we want to see the whole thing, we need to tell R to ignore that, and present it as is. To do this we can use unclass to remove the class rules. # Look at the tree as is unclass(tree) ## $edge ## [,1] [,2] ## [1,] 5 6 ## [2,] 6 7 ## [3,] 7 1 ## [4,] 7 2 ## [5,] 6 3 ## [6,] 5 4 ## ## $edge.length ## [1] 6.3 3.1 4.2 4.2 7.3 13.5 ## ## $Nnode ## [1] 3 ## ## $tip.label ## [1] &quot;robin&quot; &quot;deer&quot; &quot;spider&quot; &quot;jellyfish&quot; ## ## attr(,&quot;order&quot;) ## [1] &quot;cladewise&quot; If we only wanted to see the full edge component we can use the $ to extract just that variable from tree: # Just look at the edge variable tree$edge ## [,1] [,2] ## [1,] 5 6 ## [2,] 6 7 ## [3,] 7 1 ## [4,] 7 2 ## [5,] 6 3 ## [6,] 5 4 What is going on here? The easiest way to understand is to look at the edge matrix and the tree with node numbers added to it (see below). For all trees, 1 is the number of the first tip taxon at the base of the phylogeny, 2 is the number of the second taxon and so on until you have each taxon numbered. The numbers then refer to nodes, working through the tree from the root forwards. So in the edge matrix above, 1, 2, 3 and 4 are the tips. Node 7 leads to tips 1 and 2. Node 6 leads to node 7, and tip 3. Node 5 leads to node 6 and tip 4. Node 5 is the root node. Notice that the edge.length variable is in the same order as edge. So the first row of edge shows a branch joining node 5 to node 6, and this has a branch length of 6.3 (the first entry in edge.length). And so on… tree$edge ## [,1] [,2] ## [1,] 5 6 ## [2,] 6 7 ## [3,] 7 1 ## [4,] 7 2 ## [5,] 6 3 ## [6,] 5 4 tree$edge.length ## [1] 6.3 3.1 4.2 4.2 7.3 13.5 As I said above, you don’t need to fully understand this, so don’t worry if this is confusing. But you will see at various points we do things like tree$tip.label to extract or change tip labels, and we might set branch lengths using tree$edge.length somewhere in our code. So now you understand where those bits of information come from. 3.4 Plotting phylogenies Regardless of what you’re using a phylogeny for, you’re likely to want to plot it at some point. Even if you don’t need a plot straight away, I highly advise plotting your phylogeny before you do anything else. It’s good practice to look at whatever data you read into R to check it, and plotting helps you check it looks correct. Most phylogeny plotting in R uses the package ape. Recently, however, a new package called ggtree has been introduced that builds on the popular ggplot2 method of plotting in R, and is much more flexible than ape. This leaves us in a bit of a quandary - which should you use? And which should I teach you?! I think there is a benefit in learning the basics of both approaches. In my own work, I use ape to plot trees I am working with to quickly check what is going on. I also use ape plotting indirectly in other packages like phytools - see later exercises. When I need to produce a pretty or complex tree I’ll often use ggtree instead. The exercises here will mirror this. The aim is not to give you a thorough introduction to all the things we can do with plotting phlyogenies in R, but more to give a taster of what is possible, and what we will need for the later exercises. 3.4.1 Basic phylogeny plotting with APE Our basic tree is a bit small, so let’s use some data that is built into R with a phlyogeny of bird orders. First load the data. This will read in a tree called bird.orders. # Load the data from R data(bird.orders) Now plot the tree. # Plot the tree plot(bird.orders) Note that the function we use to plot phylogenies in ape is just called plot, but R knows to plot a phylogeny not anything else. How does this work? plot is one of a set of clever functions in R that uses an ifelse statement to decide what kind of plot it should do. When you ask R to plot something, it first determines what class of object it is. It then chooses the correct version of plot for that class. In this case the function it is actually using to plot the phylogeny is plot.phylo. This is important if you want to look at the help file for plotting phylogenies, because you need to use ?plot.phylo not ?plot. # Access the help file for phylogeny plotting # This should open a help file in another window of RStudio ?plot.phylo You should see from the help file that there are lots of options for plotting trees. For example if we want to use a fan-shaped tree, with smaller tip labels, and no white space round the edges to make the tree fill the plotting area, we can use: # Plot the tree as a circular/fan phylogeny with small labels plot(bird.orders, cex = 0.6, type = &quot;fan&quot;, no.margin = TRUE) You can change the style of the tree (type), the color of the branches and tips (edge.color, tip.color), and the size of the tip labels (cex). Here’s an fun/hideous example! plot(bird.orders, edge.color = &quot;deeppink&quot;, tip.color = &quot;springgreen&quot;, no.margin = TRUE) We can also add information about the traits of species to trees. We will come back to this when we cover models of evolution, but as a quick demonstration, let’s imagine we want to display some data on our bird tree. For example, let’s code these bird orders based on how much I like them (this is clearly a total lie because I love them all equally, but for the sake of an example I’m willing to pretend!). # Make a factor which contains how much I like each order myfaves &lt;- factor(c(&quot;awesome&quot;, &quot;cool&quot;, &quot;ok&quot;, &quot;awesome&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;awesome&quot;, &quot;cool&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;cool&quot;, &quot;cool&quot;, &quot;awesome&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;cool&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;cool&quot;, &quot;ok&quot;)) Now we can plot this on a phylogeny. First we decide which colours we’d like and make a list of these. To look at a list of inbuilt colours in R type in colors(). You can also use any hex colour coded as e.g. “#000000” instead of “white”. The first colour will be the first category alphabetically, the second will be the second category alphabetically, and so on. mycolours &lt;- c(&quot;gold&quot;, &quot;cornflowerblue&quot;, &quot;cyan4&quot;) Now plot the tree and add square labels to the tips showing the categories. We use label.offset = 1 to move the labels to the right a bit so the squares will fit. I’ve also added a legend. # Plot the tree plot(bird.orders, label.offset = 1, cex = 0.9, no.margin = TRUE) # Add the squares at the tip labels. tiplabels(pch = 22, bg = mycolours[as.numeric(myfaves)], cex = 1.2, adj = 1) # Add a legend legend(&quot;topleft&quot;, fill = mycolours, legend = c(&quot;Awesome&quot;, &quot;Cool&quot;, &quot;OK&quot;), bty = &quot;n&quot;) pch = 22 sets the tip labels to be unfilled squares, bg (background) defines the colours of the squares using the list of colours we provided, and sorting them based on what the value for that order was for myfaves. cex = 1.2 increases the point size, and adj = 1 moves the tip labels sideways a bit so they don’t obscure the ends of the branches. 3.4.2 Basic phylogeny plotting with ggtree I won’t go into a huge amount of detail about ggtree because the manual for ggtree is really comprehensive, and for the most part you won’t need to know how to do most of the things it can do. Instead I’ll give a basic introduction, and then show you how to make some of the plots used in chapter 2 of the Primer. I will also provide the code used to build figures in the Primer where appropriate in later exercises. 3.4.2.1 A quick intro to ggplot2 ggtree extends the ggplot2 package to work with phylogenies. What’s ggplot2? The ggplot2 package was developed by Hadley Wickham to implement some of the ideas in a book called “The Grammar of Graphics” by Wilkinson (2005), hence the gg bit of the name. Many books and online tutorials cover ggplot2 in detail, so here I’ll just cover the basics you need to understand how ggtree works. See https://ggplot2-book.org/ for details. ggplot2 works on the basis of layers. You start off with a line of code that uses the function ggplot, then at the end of the line you add a +. On the next line you add a layer. This layer might tell R what kind of plot to make, what the axes should be, how to draw the legend etc. You keep adding layers until you get the plot that you want. Each layer can have six components, but we’ll just focus on the main three: The data. Every layer needs some data, in the form of a dataframe (or tibble). Each layer can be associated with a different dataset if appropriate. A geometric object, called a ‘geom’. geoms refer to the things we can see on a plot, such as points, lines or bars. A set of aesthetic mappings. These describe how variables in the data are associated with the aesthetic properties of the layer. This can include what to use as x and y axes, and the colour and size of the objects (e.g. points) on a plot. Each layer can be associated with its own unique aesthetic mappings. Aesthetic mappings are always defined inside the aes function. Different geoms will need different sets of aesthetic mappings, for example to draw a scatter plot you need to define the x and y axes, but for a histogram you only need the x axis. Each layer will also have layer specific parameters. These are the features of a layer, for example in geom_point, the geom that makes points on a graph, one layer specific parameter is colour = which defines the colour of the data points. Let’s quickly demonstrate this using some fake data - read in the code below to create a monster dataset. # Make some fake data monsterdata &lt;- data.frame(monster = c(&quot;vampire&quot;, &quot;golem&quot;, &quot;cookie-monster&quot;, &quot;manticore&quot;, &quot;wererat&quot;), type = c(&quot;dead&quot;, &quot;dead&quot;, &quot;alive&quot;, &quot;dead&quot;, &quot;alive&quot;), scariness = c(65, 50, 10, 75, 95)) To make a really basic plot… ggplot(data = monsterdata, aes(x = monster, y = scariness)) + geom_point(colour = &quot;deeppink&quot;, size = 4) + theme_bw() + ylim(0, 100) A couple of points to note: In ggplot2, theme is used to define the overall look of the plot. We can use the theme function modify everything individually, but there are some built in themes that do lots of things at once. theme_bw is one of my favourites as it gets rid of the horrible grey background that is a ggplot2 default, but keeps the nice background grid. I also used ylim to change the y axis limits to go from 0 to 100. Another thing I’m going to do below with ggtree is plot multiple plots on one plotting space. There are a couple of ways to do this, but the easiest is to use the package patchwork. First we need to assign our plots to an object using &lt;-. We do this as follows myplot1 &lt;- ggplot(data = monsterdata, aes(x = monster, y = scariness)) + geom_point(colour = &quot;deeppink&quot;, size = 4) + theme_bw() + ylim(0, 100) myplot2 &lt;- ggplot(data = monsterdata, aes(x = monster, y = scariness)) + geom_point(colour = &quot;gold1&quot;, size = 4, shape = &quot;triangle&quot;) + theme_bw() + ylim(0, 100) To look at the plots we would now have to type myplot1 or myplot2 into R, but I haven’t done this here because we already looked at the first plot above, and all I changed in the second plot was the colour and shape of the points. With patchwork, we can use + to plot things next to each other, or / to plot things on top of one another, and () to do more complex arrangements. See https://patchwork.data-imaginist.com/articles/patchwork.html for details. Here let’s just plot them next to each other… library(patchwork) myplot1 + myplot2 myplot1 / (myplot1 + myplot2) Below you’ll see I use the ggplot2 layer labs to add labels (i.e. A, B, C) to plots in multi-panel figures. We can also angle the x axis labels so they fit, add trend lines etc. But I’ll let you find out how to do that for yourselves! 3.4.3 Back to ggtree OK that should give you the basics of what to expect from ggplot2. Now let’s use ggtree… To plot a phylogeny using ggtree we always start with the ggtree function (not ggplot). We then add layers using the + like in ggplot2. Some layers are the same (e.g. xlim, ylim), others are unique to ggtree (e.g. geom_tiplab). ggtree also has an inbuilt theme for trees called theme_tree. To plot the basic phylogeny we’ve been practising with we use: library(ggtree) ggtree(tree) + # Add theme for trees theme_tree() + # Change x and y limits so the tip labels fit xlim(0, 22) + ylim(0, 5) + # Add tip labels as text, slightly offset from the tips and aligned geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 0.5, linetype = NA) Note that you might need to fiddle around with the xlim and ylim a bit to make sure your phylogeny and the tip labels fit. If we don’t specify the limits, the tip labels often fall off the plotting window (see below), and the tree will push right up against the top and bottom of the page making it hard to add things like images to the tips. # Demonstration of what happens if you don&#39;t define the x and y limits ggtree(tree) + theme_tree() + geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 0.5, linetype = NA) ggtree is clearly a bit more involved than just using plot.phylo with ape. If you’re happy with plotting in ape you don’t need to use ggtree. As I mentioned above, for day-to-day tree viewing and checking I just tend to use ape, so don’t worry if this is all incomprehensible. One thing, among many, that ggtree is great for is adding images to the tips rather than species names. To do this you need to collate the images you want to use first. You may want to draw your own, or I often download them from the excellent PhyloPic website (these are free to use but don’t forget to record who made the image so you can credit them in your papers/talks). To keep my folder tidy I keep images in a separate subfolder called, predictably, images. You need the package ggimage installed for this to work, which for me took some time and also required that I install ggplotify, magick, and gridGraphics. If this is a struggle, then just skip this example. # Plot with images at tips ggtree(tree) + theme_tree() + # Change limits so labels fit xlim(0, 22) + ylim(0, 5) + # Add tip label pictures geom_tiplab(aes(image = c(&quot;images/deer.png&quot;, &quot;images/robin.png&quot;, &quot;images/spider.png&quot;, &quot;images/jellyfish.png&quot;, rep(NA, 3))), geom = &quot;image&quot;, align = TRUE, offset = 0.5, linetype = NA, size = c(0.12, 0.15, 0.09, 0.15)) Note that to add either text or images to the tips we use the same layer function, geom_tiplab. If doing this with your own data you’ll likely need to fiddle with the sizes of the images to get them looking right. Some of you may be wondering what the rep(NA, 3) bit of the code above does. When we try to add images to the tips, the function also tries to add images to the internal nodes. We don’t want these to have images so we just ask ggtree to use NA, i.e. don’t add an image. rep(NA, 3) means replicate NA three times (for the three internal nodes). Again you’ll probably need to modify this number when you do this for your own data. As with plot.phylo we can plot phylogenies in different ways, see code below. Fan trees are called circular trees. Note the different values for offset and hjust (horizontal justification) I’ve used here to make the labels fit. Again you will need to fiddle with these numbers to get this to work for your data. # Standard tree p1 &lt;- ggtree(tree) + theme_tree() + # Change limits so labels fit xlim(0, 22) + ylim(0, 5) + # Add tip labels geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 0.5, linetype = NA) + labs(tag = &quot;A&quot;, size = 2) # Standard tree facing up p2 &lt;- ggtree(tree) + theme_tree() + coord_flip() + # Change limits so labels fit xlim(0, 22) + ylim(0, 5) + # Add tip labels geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 2, hjust = 0.5, linetype = NA) + labs(tag = &quot;B&quot;, size = 2) # Slanted tree p3 &lt;- ggtree(tree, layout = &quot;slanted&quot;) + theme_tree() + # Change limits so labels fit xlim(0, 22) + ylim(0, 5) + # Add tip labels geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 0.5, linetype = NA) + labs(tag = &quot;C&quot;, size = 2) # Fan/circular tree p4 &lt;- ggtree(tree, layout = &quot;circular&quot;) + theme_tree() + # Add tip labels geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 5, hjust = 0.5, linetype = NA, size = 3) + labs(tag = &quot;D&quot;, size = 2) # Plot (p1 + p2) / (p3 + p4) What about highlighting clades? We can use geom_hilight to add coloured shading to all species from a defined node, and/or geom_cladelabel to label clades (A and B below) from a defined node. The offset in geom_cladelabel defines how far from the phylogeny tips the lines should be drawn. Again, you’ll need to play with this to get the best figure possible. # Plot with images at tips ggtree(tree) + theme_tree() + # Change limits so labels fit xlim(0, 22) + ylim(0, 5) + # Add tip label pictures geom_tiplab(aes(image = c(&quot;images/deer.png&quot;, &quot;images/robin.png&quot;, &quot;images/spider.png&quot;, &quot;images/jellyfish.png&quot;, rep(NA, 3))), geom = &quot;image&quot;, align = TRUE, offset = 0.5, linetype = NA, size = c(.12, .15, .09, .15)) + # Highlight clades geom_hilight(node = 6, fill = &quot;cornflowerblue&quot;, alpha = 0.4) + geom_hilight(node = 7, fill = &quot;springgreen&quot;, alpha = 0.4) + geom_cladelabel(node = 7 , label = &quot;A&quot;, offset = 4, fontsize = 5) + geom_cladelabel(node = 6 , label = &quot;B&quot;, offset = 6, fontsize = 5) You can also highlight non-monophyletic groups using groupOTU. Here’s a quick and silly example… # Define group feathers &lt;- list(no = c(&quot;deer&quot;,&quot;jellyfish&quot;, &quot;spider&quot;), yes = c(&quot;robin&quot;)) # Plot with images at tips p &lt;- ggtree(tree) + theme_tree() + # Change limits so labels fit xlim(0, 25) + ylim(0, 5) + # Add tip labels geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 0.5, linetype = NA) # Add colours to branches and labels groupOTU(p, feathers, &#39;feathers&#39;) + aes(color = feathers) + scale_colour_manual(values = c(&quot;orange1&quot;,&quot;darkblue&quot;)) + theme(legend.position = &quot;top&quot;) Note the warning here that tells us not to use filter_. This is from the internal ggtree code and can be ignored for now. Either this will be updated in the future, or ggtree will change how this is done. So if this code breaks completely try the ggtree help files for a solution. There are many more things you can do with ggtree, all based on this idea of adding layers. See the manual for ggtree at http://yulab-smu.top/treedata-book/index.html for more details. 3.5 Phylogeny manipulation To run analyses in R we often need to manipulate our phylogeny in some way so that the analyses can work. I’ll mention these requirements where needed, but here are some common things we might need to change. I’ll use the bird.orders phylogeny again as it’s a manageable size. # Load the tree data(bird.orders) 3.5.1 Removing polytomies Most R functions require your tree to be dichotomous, i.e. to have no polytomies. To check whether your tree is dichotomous use is.binary.tree. # Check whether the tree is binary # We want this to be TRUE is.binary.tree(bird.orders) ## [1] TRUE If this is FALSE, use multi2di to make the tree dichotomous. This function works by randomly resolving polytomies with zero-length branches. This doesn’t change the tree overall, it’s just a clever trick to get the functions to work. # Make the tree into a binary tree bird.orders &lt;- multi2di(bird.orders) 3.5.2 Rooting your phylogeny Most R functions also require the tree to be rooted, i.e., to have one (or more) taxon designated as the outgroup. We can check whether the tree is rooted as follows. # Check whether the tree is rooted # We want this to be TRUE is.rooted(bird.orders) ## [1] TRUE Our tree is rooted but if you wanted to change the root, or root an unrooted tree use root. We can make a new tree and root it on something silly (e.g. Passeriformes) to demonstrate. Remember that your root should be the outgroup from the phylogenetic inference. Rooting a tree incorrectly can cause big issues with downstream analyses, so make sure you choose carefully. new.tree &lt;- root(bird.orders, outgroup = &quot;Passeriformes&quot;) plot(new.tree) 3.5.3 Manipulating the species in your phlyogeny When we do comparative analyses, we have data and a tree to deal with. It’s very common to have species in your data that are not in your tree and vice versa. In the next exercise I’m going to show you how to match up the species in your comparative data with the species in your phylogeny. But you may also want to make these changes for plotting purposes, so it is useful to know how to do them anyway. 3.5.3.1 Renaming species We can change the names of species using gsub which stands for generalised substitution. This can help with typos etc. or if you have minor taxonomic changes to make. Here, for fun let’s rename Passeriformes… bird.orders$tip.label &lt;- gsub(&quot;Passeriformes&quot;, &quot;birbs&quot;, bird.orders$tip.label) plot(bird.orders) 3.5.3.2 Removing species Removing species uses the function drop.tip. If we want to remove birbs from the tree above.. bird.orders &lt;- drop.tip(bird.orders, tip = &quot;birbs&quot;) plot(bird.orders) You can also remove multiple tips at once… bird.orders &lt;- drop.tip(bird.orders, tip = c(&quot;Struthioniformes&quot;, &quot;Tinamiformes&quot;)) plot(bird.orders) However, if you’re looking to do something more complex like removing entire groups it’s probably easier to use the functions in the next exercise. 3.5.3.3 Adding species Sometimes you’ll find your phylogeny is missing some species that you have in your dataset. In general the easiest thing is just to omit those species from your analysis, but it may be that they’re data points you really want to keep. In which case you can add species to the tree. Before you can add the species you need to find out where in the tree the species belongs. This will require looking in the literature to find the closest relative of the species that already exists in the tree. You also need to know how long the branch should be that will attach the new species to the tree. In some cases this will also be possible to locate in the literature. In other cases, for example if you’re adding a species as a sister species to another species within its genus, you can just choose an arbitrary short branch length, e.g. 0.1 or 1. The exact value depends on the branch lengths in the tree. We can then use R to add the species to the tree. To add a species in R, we first select the node that we want to add the tip to. For example, if we want to add Big Bird to our bird.orders tree as a sister to the Galliformes, we can identify the node to add Big Bird to using: # Identify the node node &lt;- which(bird.orders$tip.label == &quot;Galliformes&quot;) # Which node is it? node ## [1] 2 We then add the species to this node using the bind.tip function in phytools: library(phytools) bird.orders_plusbigbird &lt;- bind.tip(bird.orders, tip.label = &quot;Big_Bird&quot;, where = node, position = 4.5) plot(bird.orders_plusbigbird) You can see that Big Bird has been added to the Galliformes branch. In the bind.tip function, position is the length of the new branch. Here we used 4.5, but you could use other numbers if you needed the branch to be longer or shorter (i.e. if you knew the divergence between Galliformes and Big Bird was longer ago or more recent). Note that the value of position is limited by the length of the branch you are adding the new species to. If you see the error below it means you’ve given position a value which is longer that the existing branch, and you’ll need to make it a bit smaller. Error in bind.tree(tree, tip, where = where, position = pp) : ‘position’ is larger than the branch length 3.5.4 Writing phylogenies to file After manipulating a phylogeny, if you want to save the new tree you can use write.tree or write.nexus as preferred. You can then use this modified tree for you analyses or plots, meaning that you don’t have to do all the manipulation again every time you want to use it. If we want to save the Big Bird tree we can use: write.nexus(bird.orders_plusbigbird, file = &quot;bigbirdtree.nex&quot;) 3.6 Summary This exercise should have given you the skills to understand, plot and manipulate phylogenies in R. 3.7 Practical exercise Read in the frog-tree.nex phylogeny from the folder. This comes from Feng et al. (2017). Then do the following: Use R functions to determine: how many species are in the tree? is the tree fully resolved? is the tree rooted? Use plot.phylo to plot the tree. Can you change the size of the tip labels? Can you make a fan-shaped plot? Can you change the colour of the tips and branches? Save the tree to file as “mysuperdoopertree.nex” EXTRA FUN. Use ggtree and the ggtree manual to produce a phylogeny plot of this tree that you could use in a publication OR have some fun and make the most garish looking tree you possibly can. Playing around with these packages is the best way to learn how to use them. If you make a particularly amazing or horrific tree, send a screenshot to me. References "],["preparing-your-tree-and-data-for-pcms-in-r.html", "Chapter 4 Preparing your tree and data for PCMs in R 4.1 Before you start 4.2 Preparation 4.3 Reading and checking your phylogeny in R 4.4 Reading the data into R 4.5 Matching your data to your phylogeny 4.6 Quick template code 4.7 Summary 4.8 Practical exercise", " Chapter 4 Preparing your tree and data for PCMs in R Before we do any analysis in R we will generally need to clean and tidy our data. Data cleaning involves looking for errors, for example we might need to remove duplicate columns, or correct typos in species names, or make sure column headers are all unique and easy enough for us to type in R. We also often need to tidy our data. For data to be tidy: Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. The R packages dplyr, tidyr are great for data cleaning and tidying. See https://r4ds.had.co.nz/tidy-data.html for more details on what tidy data is and how to do this in R. Of course you are welcome to do this in Excel or another package if you’re more comfortable with that. The important thing is that when you begin your analyses, your data are in a suitable format. Note that a detailed introduction to data manipulation in R is beyond the scope of this Primer, but if in doubt about your data, try and make it look as much like our example datasets as possible. If you can do that, these R analyses should work for you! :) In this exercise we will take an existing tree and some data and prepare them for a PCM analysis. Note that prior to this step, it is important that your data is in a tidy format, and has been thoroughly checked for errors. The exercise below only shows you how to deal with additional issues caused by using trees and then matching species data to those trees. We assume the tree and data themselves are fit for purpose. We will be using the evolution of eye size in frogs as an example. The data and modified tree come from Thomas et al. (2020), and the original tree comes from Feng et al. (2017). I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out Thomas et al. (2020)! 4.1 Before you start Open the 04-Preparation.RProj file in the 04-Preparation folder to open your R Project for this exercise. Make yourself a new R script for your code. You will also need to install the following packages: ape geiger tidyverse treeplyr 4.2 Preparation To begin we need to load the packages for this practical. # Load packages library(ape) library(geiger) library(tidyverse) library(treeplyr) 4.3 Reading and checking your phylogeny in R We already learned how to do these things in 03-Phylogenies. If you haven’t looked at that exercise I suggest you check it out before doing the steps below. First let’s read in the tree and look at its structure: # Read in the tree frogtree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Look at the tree summary frogtree ## ## Phylogenetic tree with 214 tips and 213 internal nodes. ## ## Tip labels: ## Ascaphus_truei_Ascaphidae, Leiopelma_hochstetteri_Leiopelmatidae, Alytes_obstetricans_Alytidae, Discoglossus_pictus_Alytidae, Barbourula_busuangensis_Bombinatoridae, Bombina_orientalis_Bombinatoridae, ... ## ## Rooted; includes branch lengths. It’s usually a good idea to quickly plot the tree too… # Plot the tree as a circular/fan phylogeny with small labels plot(frogtree, cex = 0.2, typ = &quot;fan&quot;, no.margin = TRUE) frogtree is a fully resolved tree with branch lengths. There are 214 species and 213 internal nodes. Note that the species names at the tips also have family names added to them… # Look at the first 5 tip labels frogtree$tip.label[1:5] ## [1] &quot;Ascaphus_truei_Ascaphidae&quot; ## [2] &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; ## [3] &quot;Alytes_obstetricans_Alytidae&quot; ## [4] &quot;Discoglossus_pictus_Alytidae&quot; ## [5] &quot;Barbourula_busuangensis_Bombinatoridae&quot; Most trees will have just the genus and species names, but some will have additional information like here, or numbering etc. This is not a problem as long as the names match those in your data (see below). Most R functions require your tree to be dichotomous, i.e. to have no polytomies. To check whether your tree is dichotomous use is.binary.tree. # Check whether the tree is binary # We want this to be TRUE is.binary.tree(frogtree) ## [1] TRUE If this was FALSE, we’d use multi2di to make the tree dichotomous, but here it is TRUE so we can leave it as it is. Most functions also require the tree to be rooted, i.e., to have one taxon designated as the outgroup. We can check whether the tree is rooted as follows. # Check whether the tree is rooted # We want this to be TRUE is.rooted(frogtree) ## [1] TRUE Our tree is rooted so it’s ready to go. Finally we might want to check that the tree is ultrametric. Most functions will assume this, and although we can see the tree looks ultrametric when we plotted it above, we should still check. # Check the tree is ultrametric is.ultrametric(frogtree) ## [1] TRUE If this is FALSE there are two options. If the tree really is non-ultrametric, for example if it contains fossil species, then we can’t use it in methods that require an ultrametric tree. However, there are cases (the dragonfly tree in Chapter 11 is one example) where the tree is non-ultrametric due to a rounding error. In the latter case we can use the phytools function force.ultrametric to fix this. When can a tree that looks ultrametric appear to be non-ultrametric? Most of the methods we use expect trees to be ultrametric, i.e. that all the tips line up, generally at the present day (time 0). Sometimes (see Chapter 11 the tree and it looks ultrametric, but when we check using is.ultrametric the answer returned is FALSE. What is going on? The tree is actually ultrametric, and will run in most analyses with R treating it as an ultrametric tree. The reason is.ultrametric tells us it is not ultrametric is related to rounding errors. When you save a tree file, it will save the branch lengths to a certain level of accuracy, but not always the full level of accuracy if your branch lengths have lots and lots of decimal places. When you read these trees back into R, a teeny tiny bit of the accuracy is lost which sometimes means that when R adds up the root-to-tip distances for each tip, they aren’t all exactly the same length, so therefore technically the tree is not ultrametric. For most implementations this tiny difference is not a big deal. A quick fix to this problem is to use the function force.ultrametric which essentially fudges the numbers to force the tree to be ultrametric. If your tree is genuinely non-ultrametric you should not use this function as it can introduce negative branch lengths which will break most functions you might want to use in R. 4.4 Reading the data into R The data are in a comma-delimited text file called frog-eyes.csv. Load these data as follows. # Read in the data frogdata &lt;- read_csv(&quot;data/frog-eyes.csv&quot;) Check everything loaded correctly: # Look at the data glimpse(frogdata) ## Rows: 215 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Aly… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alyt… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglos… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus… ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelli… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Fr… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.6000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.… ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.11666… As you can see, the data contains 215 species, and the following 11 variables: Binomial - the species binomial name. Family - the family the species belongs to. Genus - the genus the species belongs to. tiplabel - the name used for the species in the phylogeny. Adult_habitat - habitat of adults. Categories are: Ground-dwelling, Subfossorial, Scansorial (i.e. tree-dwelling), Semiaquatic, Aquatic, or Fossorial (i.e. burrowers). Life_history - whether the larvae are free-living (Free-living larvae) or not (No free-living larvae). Sex_dichromatism - whether different sexes are different colours (Present) or not (Absent). SVL - snout vent length (in mm). This is a common way to measure body size in amphibians. mass - body mass (in g). rootmass - cube root of the body mass. eyesize - eye size (in mm) for the species. This is an everage across left and right eyes from three individuals per species. Note that in some comparative datasets (most of mine for instance) the species names column (here Binomial) also contains the names of the species in the tree so we would match up that column to the species names in the tree (see below). In this dataset and others, the authors have instead included the names of the tips of the tree as a separate column (here tiplabel). This is often done when the tips of the tree are not species names, but are instead some kind of code. This is common where the tree contains multiple tips for one species, or where the tip labels contain additional information (here they include family names). A final approach used by some authors is to have the species names as the row names of the dataset. Any approach is fine, but make sure you know which column contains the names that should match up with the tree. 4.5 Matching your data to your phylogeny Now we have the tree and the data in R, we need to match the two up if we want to perform any kind of PCM analyses. Below are some common issues you might encounter, and how to fix them. 4.5.1 Species names with spaces Species names in phylogenies are generally written as Genus_species (the gap between the genus name and species name is replaced by an underscore _). If the species names in the data are written as Genus species with a space, then you will have to replace the spaces with _ so that they match up with the species names in the tree. You can do this as follows using str_replace. We don’t need to do this in our frog data, but if we did we could use code like this: # Replace spaces with underscores in species names frogdata &lt;- frogdata %&gt;% mutate(Binomial = str_replace(string = Binomial, pattern = &quot; &quot;, replacement = &quot;_&quot;)) # Check it worked head(frogdata$Binomial) Beware trailing spaces! If you’re trying to match up species names and are having some trouble, check what happened when you replaced spaces with underscores (_). Sometimes we accidentally leave extra spaces when typing, and R will convert these to underscores too which can cause problems. For example, Genus_species can become Genus_species_ if you accidentally left a trailing space. Check all the names in your dataset after replacing the spaces to make sure this is not a problem. 4.5.2 Mismatches between species in your data and phylogeny Often you will have data for species which are not in your phylogeny and/or species in your phylogeny which are not in your data. Many functions in R can deal with this and will match the species for you, others will produce an error telling you the tree and data do not match (e.g. most ape functions). Even in functions that can cope with this, it’s useful to match up the species before your analyses. This can help you identify things like spelling mistakes or variations in the taxonomy of the tree and the data. If you have even slightly misspelled a species name in the tree or the data it will automatically be dropped from the analyses. It is therefore very important to check this before running an analysis, especially one with lots of taxa. We can use the geiger function name.check to find out which names do not match. Remember that the species names that match up with the tree from frogdata are in the variable called tiplabel. # Check whether the names match in the data and the tree check &lt;- name.check(phy = frogtree, data = frogdata, data.names = frogdata$tiplabel) The output of check has two parts, tree_not_data for species in the tree but not in the dataset, and data_not_tree for species in the dataset but not in the tree. You need to look at both of these in turn. # Look at species in the tree but not the data check$tree_not_data ## [1] &quot;Incilius_nebulifer_Bufonidae&quot; ## [2] &quot;Leptobrachella_bidoupensis_Megophryidae&quot; ## [3] &quot;Microhyla_fissipes_Microhylidae&quot; ## [4] &quot;Microhyla_marmorata_Microhylidae&quot; There are four species in the tree and not the data. We were expecting this here, so no worries. For your analyses you should always check this list carefully. If I were running this analysis for the first time I’d want to check that these species really weren’t in my data. Maybe they are misspelled in the data? If so correct this now. Maybe the species name has changed? If so change this now. It doesn’t really matter whether you make the change in the tree or the data, but make sure anything that should match up, does. I’d usually fix issues in the dataset in Excel or another spreadsheet program, unless it’s a blatant typo in the tree. Next check the species in the data but not the tree. # Look at species in the data but not the tree check$data_not_tree ## [1] &quot;Gastrophryne_carolinensis_Microhylidae&quot; ## [2] &quot;Leptobrachella_dringi_Megophryidae&quot; ## [3] &quot;Megophrys_gerti_Megophryidae&quot; ## [4] &quot;Microhyla_pulverata_Microhylidae&quot; ## [5] &quot;Oreobates_quixensis_Strabomantidae&quot; This gives us five species in the data but not in the tree. As above, make sure to correct any errors before moving to the next step. Make sure anything that should match up, does match up. Here we know that these species are missing from our data, so we don’t need to worry. 4.5.3 Matching the tree and the data Finally, once we know which species do not match up, we need to remove species missing from the data from the tree, and remove species missing from the tree from the data. This used to be a bit of a pain, but treeplyr makes it easy. treeplyr has a lot of really cool functions, see the wiki for more details. However, here we are just going to use it just to match up the tree and the data. We’ll use the function make.treedata to combine the tree and the dataset into one object. We need to provide the name of the tree, the name of the data, and specify which column our species names are in. # Combine and match the tree and data frogstuff &lt;- make.treedata(tree = frogtree, data = frogdata, name_column = &quot;tiplabel&quot;) Note that we could leave out the name_column = tiplabel argument, in which case the function make.treedata will search the data for the column with the contents that have most matches to the tree, and automatically use this column for matching up species names. It will also search the rownames. To look at the tree and data combined we can use summary: summary(frogstuff) ## A treeplyr treedata object ## The dataset contains 10 traits ## Continuous traits: Binomial Family Genus SVL mass rootmass eyesize ## Discrete traits: Adult_habitat Life_history Sex_dichromatism ## The following traits have missing values: Life_history, Sex_dichromatism ## These taxa were dropped from the tree: Oreobates_quixensis_Strabomantidae, Leptobrachella_dringi_Megophryidae, Megophrys_gerti_Megophryidae, Gastrophryne_carolinensis_Microhylidae, Microhyla_pulverata_Microhylidae ## These taxa were dropped from the data: Leptobrachella_bidoupensis_Megophryidae, Incilius_nebulifer_Bufonidae, Microhyla_fissipes_Microhylidae, Microhyla_marmorata_Microhylidae ## $phy ## ## Phylogenetic tree with 210 tips and 209 internal nodes. ## ## Tip labels: ## Ascaphus_truei_Ascaphidae, Leiopelma_hochstetteri_Leiopelmatidae, Alytes_obstetricans_Alytidae, Discoglossus_pictus_Alytidae, Barbourula_busuangensis_Bombinatoridae, Bombina_orientalis_Bombinatoridae, ... ## ## Rooted; includes branch lengths. ## ## $dat ## # A tibble: 210 x 10 ## Binomial Family Genus Adult_habitat Life_history Sex_dichromatism SVL ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 Ascaphu… Ascap… Asca… Semiaquatic Free-living… Absent 39.0 ## 2 Leiopel… Leiop… Leio… Semiaquatic Free-living… Absent 39.0 ## 3 Alytes_… Alyti… Alyt… Ground-dwell… Free-living… Absent 37.5 ## 4 Discogl… Alyti… Disc… Ground-dwell… Free-living… Absent 62.6 ## 5 Barbour… Bombi… Barb… Aquatic &lt;NA&gt; Absent 59.5 ## 6 Bombina… Bombi… Bomb… Semiaquatic Free-living… Absent 42.8 ## 7 Bombina… Bombi… Bomb… Semiaquatic Free-living… Absent 76.6 ## 8 Rhinoph… Rhino… Rhin… Fossorial Free-living… Absent 67.7 ## 9 Pipa_ca… Pipid… Pipa Aquatic Free-living… Absent 46.7 ## 10 Pipa_pi… Pipid… Pipa Aquatic No free-liv… Absent 119. ## # … with 200 more rows, and 3 more variables: mass &lt;dbl&gt;, rootmass &lt;dbl&gt;, ## # eyesize &lt;dbl&gt; You may notice that make.treedata has two objects within it, the tree and the data. You can access the tree using frogstuff$phy and the data using frogstuff$dat. Let’s look at the phylogeny first… # Look at the tree summary frogstuff$phy ## ## Phylogenetic tree with 210 tips and 209 internal nodes. ## ## Tip labels: ## Ascaphus_truei_Ascaphidae, Leiopelma_hochstetteri_Leiopelmatidae, Alytes_obstetricans_Alytidae, Discoglossus_pictus_Alytidae, Barbourula_busuangensis_Bombinatoridae, Bombina_orientalis_Bombinatoridae, ... ## ## Rooted; includes branch lengths. The matched phylogeny has 210 species in it (instead of the original 214 species in frogtree because the four that weren’t in the data have been removed). Now let’s look at the data. What is missing? # Look at the data glimpse(frogstuff$dat) ## Rows: 210 ## Columns: 10 ## $ Binomial &lt;fct&gt; Ascaphus_truei, Leiopelma_hochstetteri, Alytes_… ## $ Family &lt;fct&gt; Ascaphidae, Leiopelmatidae, Alytidae, Alytidae,… ## $ Genus &lt;fct&gt; Ascaphus, Leiopelma, Alytes, Discoglossus, Barb… ## $ Adult_habitat &lt;fct&gt; Semiaquatic, Semiaquatic, Ground-dwelling, Grou… ## $ Life_history &lt;fct&gt; Free-living larvae, Free-living larvae, Free-li… ## $ Sex_dichromatism &lt;fct&gt; Absent, Absent, Absent, Absent, Absent, Absent,… ## $ SVL &lt;dbl&gt; 38.95000, 38.96667, 37.46667, 62.64000, 59.4750… ## $ mass &lt;dbl&gt; 6.000000, 5.333333, 6.666667, 24.400000, 24.250… ## $ rootmass &lt;dbl&gt; 1.809268, 1.740547, 1.869060, 2.888547, 2.73310… ## $ eyesize &lt;dbl&gt; 5.587500, 6.283333, 6.366667, 7.550000, 8.23750… We now have 210 species in the dataset too, great! But hopefully you noticed that the column with the species names in it (tiplabel) has disappeared! treeplyr is designed to work with R functions that assume species names will be in the row names of your data. However, not all PCMs in R work this way, and I personally like to be able to see species names when I quickly look at a dataset. We can make a new species names column using the tip labels from the phylogeny, as make.treedata orders the data so it’s the same as the tip labels. # Make a new column called tiplabel with the tip labels in it frogstuff$dat$tiplabel &lt;- frogstuff$phy$tip.label Finally we might want to rename the tree and data to make them a bit less clunky when typing in your code. # Save tree as mytree mytree &lt;- frogstuff$phy # Save data as mydata mydata &lt;- frogstuff$dat For the data, I’m also going to add one last trick to make our lives easier. treeplyr relies on the tidyverse set of packages, which create special data frames of a class called tibbles. Tibbles are great, but some older PCM functions cannot work with them, and need the data to be in an ordinary data frame instead. We can fix this using as.data.frame. # Look at the class of mydata class(mydata) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; # Force mydata to be a data frame mydata &lt;- as.data.frame(mydata) # Check mydata is now a dataframe class(mydata) ## [1] &quot;data.frame&quot; Finally, we might want to output these cleaned and tidied data and tree to our folder so rather than doing this every time we start an analysis, we can just use these tidy versions. To do this we can use: # Write the cleaned data to a new file write_csv(mydata, path = &quot;data/clean-frog-data.csv&quot;) # Write the cleaned tree to a new file write.nexus(mytree, file = &quot;data/clean-frog-tree.nex&quot;) Note, however, that you will have to repeat this preparation process if you add species or data to your tree or dataset at a later date. 4.5.4 Subsetting your tree and data Another thing that treeplyr makes a lot easier is subsetting your tree and data. It’s fairly common, especially with large phylogenies, that we might want to run our analyses on subsets of the data. Generally these are taxonomic divisions, but you might also want to divide your analyses into large and small body size species, for example. One solution would be to make a new dataset, and then run through the same procedure as we’ve used above. However, we can instead just subset the tree data object itself using filter. This works the same as filter normally does in dplyr. As an example, let’s select only species in the family Bufonidae (toads). # Subset only the species in the Bufonidae family bufonidae &lt;- filter(frogstuff, Family == &quot;Bufonidae&quot;) # Plot tree to check it worked plot(bufonidae$phy) If you want to use this in later analyses, you might want to save these as separate data and phylogeny objects, and don’t forget to make the data into a dataframe. Another thing that could be useful here is to subset so that you have a complete set of variables for certain analyses. For example let’s see how many “NAs” there are in each of our variables (don’t worry too much about this code if it seems confusing to you!): mydata %&gt;% dplyr::select(everything()) %&gt;% summarise_all(list(~ sum(is.na(.)))) ## Binomial Family Genus Adult_habitat Life_history Sex_dichromatism SVL ## 1 0 0 0 0 22 36 0 ## mass rootmass eyesize tiplabel ## 1 0 0 0 0 22 species don’t have a value for Life_history, and 36 species don’t have a value for Sex_dichromatism. Many PCMs will just ignore NA values, but if you needed to remove these you could subset them out as follows, leaving only the 163 species with complete data. # Subset out the species with NA values for some variables frog_noNA &lt;- filter(frogstuff, !is.na(Life_history) &amp; !is.na(Sex_dichromatism)) # Look at the data glimpse(frog_noNA$dat) ## Rows: 163 ## Columns: 11 ## $ Binomial &lt;fct&gt; Ascaphus_truei, Leiopelma_hochstetteri, Alytes_… ## $ Family &lt;fct&gt; Ascaphidae, Leiopelmatidae, Alytidae, Alytidae,… ## $ Genus &lt;fct&gt; Ascaphus, Leiopelma, Alytes, Discoglossus, Bomb… ## $ Adult_habitat &lt;fct&gt; Semiaquatic, Semiaquatic, Ground-dwelling, Grou… ## $ Life_history &lt;fct&gt; Free-living larvae, Free-living larvae, Free-li… ## $ Sex_dichromatism &lt;fct&gt; Absent, Absent, Absent, Absent, Absent, Absent,… ## $ SVL &lt;dbl&gt; 38.95000, 38.96667, 37.46667, 62.64000, 42.7666… ## $ mass &lt;dbl&gt; 6.000000, 5.333333, 6.666667, 24.400000, 5.3333… ## $ rootmass &lt;dbl&gt; 1.809268, 1.740547, 1.869060, 2.888547, 1.74054… ## $ eyesize &lt;dbl&gt; 5.587500, 6.283333, 6.366667, 7.550000, 5.70000… ## $ tiplabel &lt;chr&gt; &quot;Ascaphus_truei_Ascaphidae&quot;, &quot;Leiopelma_hochste… 4.6 Quick template code To help you do this with your own data, I’ve condensed the above into one script below so you don’t forget any of the steps. # Load packages library(ape) library(geiger) library(tidyverse) library(treeplyr) # Read in the tree frogtree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Look at the tree summary str(frogtree) # Plot the tree as a circular/fan phylogeny with small labels plot(frogtree, cex = 0.2, typ = &quot;fan&quot;, no.margin = TRUE) # Check whether the tree is binary # We want this to be TRUE is.binary.tree(frogtree) # Check whether the tree is rooted # We want this to be TRUE is.rooted(frogtree) # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(frogtree) # Read in the data frogdata &lt;- read_csv(&quot;data/frog-eyes.csv&quot;) # Look at the data glimpse(frogdata) # Check whether the names match in the data and the tree check &lt;- name.check(phy = frogtree, data = frogdata, data.names = frogdata$tiplabel) # Look at check check ### Correct any typos/taxonomic errors in the tree or data ### # Combine and match the tree and data frogstuff &lt;- make.treedata(tree = frogtree, data = frogdata, name_column = &quot;tiplabel&quot;) # Look at the tree summary frogstuff$phy # Look at the data glimpse(frogstuff$dat) # Make a new column called tiplabel with the tip labels in it frogstuff$dat$tiplabel &lt;- frogstuff$phy$tip.label # Save tree as mytree mytree &lt;- frogstuff$phy # Save data as mydata mydata &lt;- frogstuff$dat # Force mydata to be a data frame mydata &lt;- as.data.frame(mydata) # Check mydata is now a dataframe str(mydata) ## OPTIONAL # Make any required subsets of the tree/data ## OPTIONAL # Write the cleaned data to a new file write_csv(mydata, path = &quot;data/clean-frog-data.csv&quot;) # Write the cleaned tree to a new file write.nexus(mytree, file = &quot;data/clean-frog-tree.nex&quot;) 4.7 Summary You should now know how to prepare your tree and dataset for a PCM analysis in R. 4.8 Practical exercise In the data folder there is another tree (consensusTree_10kTrees_Version2.nex) and dataset (primate-life-history-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis. You will need to do this for the practical exercises in the next few practicals so save your code! References "],["phylogenetic-signal-in-r.html", "Chapter 5 Phylogenetic Signal in R 5.1 Before you start 5.2 Preparation 5.3 Estimating phylogenetic signal for continuous variables 5.4 Estimating phylogenetic signal for non-continuous variables 5.5 Summary 5.6 Practical exercises", " Chapter 5 Phylogenetic Signal in R Phylogenetic signal is the pattern where close relatives have more similar trait values than more distant relatives. The aims of this exercise are to learn how to use R to estimate phylogenetic signal using Pagel’s \\(\\lambda\\) (Pagel 1997, @pagel1999inferring) and Blomberg’s K (Blomberg, Garland Jr, and Ives 2003). We will be using the evolution of eye size in frogs as an example. The data and modified tree come from Thomas et al. (2020), and the original tree comes from Feng et al. (2017). I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out Thomas et al. (2020)! 5.1 Before you start Open the 05-PhyloSignal.RProj file in the 05-PhyloSignal folder to open your R Project for this exercise. Make yourself a new R script for your code. You will also need to install the following packages: tidyverse ape geiger treeplyr phytools caper 5.2 Preparation To begin we need to load the packages for this practical. # Load the packages library(tidyverse) library(ape) library(geiger) library(treeplyr) library(phytools) library(caper) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. It is important to do these things before beginning a phylogenetic comparative analysis, so let’s run through that code again here. # Read in the data frogdata &lt;- read_csv(&quot;data/frog-eyes.csv&quot;) # Check everything loaded corrected glimpse(frogdata) ## Rows: 215 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Aly… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alyt… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglos… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus… ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelli… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Fr… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.6000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.… ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.11666… To load the tree we will use read.nexus. # Read in the tree frogtree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Check it loaded correctly str(frogtree) ## List of 4 ## $ edge : int [1:426, 1:2] 215 216 217 218 219 220 221 222 223 224 ... ## $ edge.length: num [1:426] 0.166 0.114 0.102 0.4 0.133 ... ## $ Nnode : int 213 ## $ tip.label : chr [1:214] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary.tree(frogtree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(frogtree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(frogtree) ## [1] TRUE Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further. # Check whether the names match in the data and the tree check &lt;- name.check(phy = frogtree, data = frogdata, data.names = frogdata$tiplabel) # Look at check check ## $tree_not_data ## [1] &quot;Incilius_nebulifer_Bufonidae&quot; ## [2] &quot;Leptobrachella_bidoupensis_Megophryidae&quot; ## [3] &quot;Microhyla_fissipes_Microhylidae&quot; ## [4] &quot;Microhyla_marmorata_Microhylidae&quot; ## ## $data_not_tree ## [1] &quot;Gastrophryne_carolinensis_Microhylidae&quot; ## [2] &quot;Leptobrachella_dringi_Megophryidae&quot; ## [3] &quot;Megophrys_gerti_Megophryidae&quot; ## [4] &quot;Microhyla_pulverata_Microhylidae&quot; ## [5] &quot;Oreobates_quixensis_Strabomantidae&quot; Here all the excluded species are excluded because they are genuinely missing, not because of any typos, so we can move on. Next we combine the tree and data to exclude species that are not in both, using the treeplyr function make.treedata. # Combine and match the tree and data frogstuff &lt;- make.treedata(tree = frogtree, data = frogdata, name_column = &quot;tiplabel&quot;) # Look at the tree frogstuff$phy ## ## Phylogenetic tree with 210 tips and 209 internal nodes. ## ## Tip labels: ## Ascaphus_truei_Ascaphidae, Leiopelma_hochstetteri_Leiopelmatidae, Alytes_obstetricans_Alytidae, Discoglossus_pictus_Alytidae, Barbourula_busuangensis_Bombinatoridae, Bombina_orientalis_Bombinatoridae, ... ## ## Rooted; includes branch lengths. # Look at the data glimpse(frogstuff$dat) ## Rows: 210 ## Columns: 10 ## $ Binomial &lt;fct&gt; Ascaphus_truei, Leiopelma_hochstetteri, Alytes_… ## $ Family &lt;fct&gt; Ascaphidae, Leiopelmatidae, Alytidae, Alytidae,… ## $ Genus &lt;fct&gt; Ascaphus, Leiopelma, Alytes, Discoglossus, Barb… ## $ Adult_habitat &lt;fct&gt; Semiaquatic, Semiaquatic, Ground-dwelling, Grou… ## $ Life_history &lt;fct&gt; Free-living larvae, Free-living larvae, Free-li… ## $ Sex_dichromatism &lt;fct&gt; Absent, Absent, Absent, Absent, Absent, Absent,… ## $ SVL &lt;dbl&gt; 38.95000, 38.96667, 37.46667, 62.64000, 59.4750… ## $ mass &lt;dbl&gt; 6.000000, 5.333333, 6.666667, 24.400000, 24.250… ## $ rootmass &lt;dbl&gt; 1.809268, 1.740547, 1.869060, 2.888547, 2.73310… ## $ eyesize &lt;dbl&gt; 5.587500, 6.283333, 6.366667, 7.550000, 8.23750… Then we replace the removed species names column, and save the data as a dataframe for later analyses. # Make a new column called tiplabel with the tip labels in it frogstuff$dat$tiplabel &lt;- frogstuff$phy$tip.label # Force mydata to be a data frame mydata &lt;- as.data.frame(frogstuff$dat) Finally we save the tree: # Save tree as mytree mytree &lt;- frogstuff$phy Note that is is possible to use the make.treedata object directly to run some analyses, but we have saved these separately here as many PCMs cannot work with this. Now we’re ready to run our analyses! 5.3 Estimating phylogenetic signal for continuous variables As is common in R, there are a number of ways to estimate Pagel’s \\(\\lambda\\) and Blomberg’s K. I’ve chosen to show you the way implemented in the package phytools because it allows you to use the same function for both. Why do we look at two different measures of phylogenetic signal? We don’t have to, you could choose one and stick to it. However, I guarantee if you choose one then a reviewer/your supervisor/boss will ask for the other, so why not do both and pop one in the appendix? Let’s estimate \\(\\lambda\\) for log eye size. The first thing we need to do is to create an object in R that only contains the variable required, and the species names (so we can match it up to the tree). We can use the function pull to extract just the eye size values, and we can log transform all these numbers using log if we want to work with log eye size values. # Create logEye containing just log eye size length values logEye &lt;- log(pull(mydata, eyesize)) # Look at the first few rows head(logEye) ## [1] 1.720532 1.837901 1.851076 2.021548 2.108697 1.740466 Notice that this is currently just a long list of numbers. We can then name these values with the species names from mydata using the function names. Note that this requires the trait data is in the same order as the tree tip labels, but luckily make.treedata does this automatically. # Give log Eye names = species names at the tips of the phylogeny names(logEye) &lt;- mydata$tiplabel # Look at the first few rows head(logEye) ## Ascaphus_truei_Ascaphidae ## 1.720532 ## Leiopelma_hochstetteri_Leiopelmatidae ## 1.837901 ## Alytes_obstetricans_Alytidae ## 1.851076 ## Discoglossus_pictus_Alytidae ## 2.021548 ## Barbourula_busuangensis_Bombinatoridae ## 2.108697 ## Bombina_orientalis_Bombinatoridae ## 1.740466 Now we have a list of values with associated species names. 5.3.1 Pagel’s \\(\\lambda\\) We can now estimate \\(\\lambda\\) using the function phylosig: # Estimate lambda lambdaEye &lt;- phylosig(mytree, logEye, method = &quot;lambda&quot;, test = TRUE) test = TRUE specifies that we want to run a likelihood ratio test to determine if \\(\\lambda\\) is significantly different from 0. To look at the output we just type in the name of the model; lambdaEye in this case lambdaEye ## ## Phylogenetic signal lambda : 0.802864 ## logL(lambda) : -112.137 ## LR(lambda=0) : 62.803 ## P-value (based on LR test) : 2.28447e-15 The \\(\\lambda\\) estimate for log eye size is around 0.803. logL is the log-likelihood, LR(lambda=0) is the log-likelihood for \\(\\lambda\\) of 0, and P-value is the p value from a likelihood ratio test testing whether \\(\\lambda\\) is significantly different from 0 (no phylogenetic signal). Here P &lt; 0.001. We interpret this as \\(\\lambda\\) being significantly different from 0, i.e. there is significant phylogenetic signal in log eye size. 5.3.2 Blomberg’s K (Blomberg et al 2003) To estimate Blomberg’s K we also use phylosig but with method = K. # Estimate Blomberg’s *K* KEye &lt;- phylosig(mytree, logEye, method = &quot;K&quot;, test = TRUE, nsim = 1000) Additionally we add the argument nsim = 1000. This is because we need to use a randomisation test to determine whether K is significantly different from 0. phylosig randomly assigns the trait values to the species and then calculates K as many times as we ask it to in nsim (number of simulations). Here we asked for 1000. After the random simulations are run, the observed value of K is then compared to the randomized values. The p value tells us how many times out of 1000, a randomised value of K is more extreme than the observed value. If this number is low, the p value is low (e.g. if 5 out of 1000 randomised values of K are more extreme than the observed value p = 5/1000 = 0.005). As above, to look at the output we just type in the name of the model; KEye in this case KEye ## ## Phylogenetic signal K : 0.283009 ## P-value (based on 1000 randomizations) : 0.001 K for log eye size is 0.283. The p value tells us how many times out of 1000, a randomised value of K is more extreme than the observed value. If this number is low, the p value is low (e.g. if 5 out of 1000 randomised values of K are more extreme than the observed value p = 5/1000 = 0.005). Here p = 0.001, suggesting that only 1 randomised value of K was more extreme than the observed value. We interpret this as K being significantly different from 0, i.e. there is significant phylogenetic signal in log eye size. Remember that when fitting models to account for phylogenetic non-independence, it is not phylogenetic signal in the individual variables that is important. It is phylogenetic signal in the residuals of the model that matters. Evidence of phylogenetic signal in variable X (or variable Y) does not necessarily mean that there will be phylogenetic signal in the residuals of a model correlating variable X with variable Y. Conversely, lack of evidence of phylogenetic signal in variable X (or variable Y) does not necessarily mean that there will be no phylogenetic signal in the residuals of a model correlating variable X with variable Y. 5.4 Estimating phylogenetic signal for non-continuous variables Not all variables are continuous, some are categorical, some are binary. For example in the frog data Adult_habitat, Life_history and Sex_dichromatism are categorical variables. We can also code Sex_dichromatism as a binary variable if we code Absent as 0 and Present as 1. glimpse(mydata) ## Rows: 210 ## Columns: 11 ## $ Binomial &lt;fct&gt; Ascaphus_truei, Leiopelma_hochstetteri, Alytes_… ## $ Family &lt;fct&gt; Ascaphidae, Leiopelmatidae, Alytidae, Alytidae,… ## $ Genus &lt;fct&gt; Ascaphus, Leiopelma, Alytes, Discoglossus, Barb… ## $ Adult_habitat &lt;fct&gt; Semiaquatic, Semiaquatic, Ground-dwelling, Grou… ## $ Life_history &lt;fct&gt; Free-living larvae, Free-living larvae, Free-li… ## $ Sex_dichromatism &lt;fct&gt; Absent, Absent, Absent, Absent, Absent, Absent,… ## $ SVL &lt;dbl&gt; 38.95000, 38.96667, 37.46667, 62.64000, 59.4750… ## $ mass &lt;dbl&gt; 6.000000, 5.333333, 6.666667, 24.400000, 24.250… ## $ rootmass &lt;dbl&gt; 1.809268, 1.740547, 1.869060, 2.888547, 2.73310… ## $ eyesize &lt;dbl&gt; 5.587500, 6.283333, 6.366667, 7.550000, 8.23750… ## $ tiplabel &lt;chr&gt; &quot;Ascaphus_truei_Ascaphidae&quot;, &quot;Leiopelma_hochste… Estimating phylogenetic signal in categorical variables is tricky. Let’s take Adult_habitat as an example. In this variable we have the following categories: mydata %&gt;% dplyr::select(Adult_habitat) %&gt;% distinct() ## Adult_habitat ## 1 Semiaquatic ## 2 Ground-dwelling ## 3 Aquatic ## 4 Fossorial ## 5 Subfossorial ## 6 Scansorial Remember with phylogenetic signal we are looking for the pattern where close relatives are more similar to one another than more distant relatives. For these categories, it would be sensible to say we had high phylogenetic signal if, for example, all toads are Semiaquatic, and all tree frogs are Scansorial (climbers). But what if some toads are Semiaquatic but others are Ground-dwelling? If we don’t know how species transition from state to state, it’s hard to know what we might expect to see as evolutionary distance between species increases. We might sensibly assume that species easily evolve from Semiaquatic to Aquatic, or from Subfossorial to Fossorial (burrowing), but what about changes from Aquatic to Fossorial? All of this makes phylogenetic signal for categorical variables a bit of a mess. There are a couple of, more or less satisfying, solutions… Do we actually need to know the phylogenetic signal for these variables? For the models we are interested in phylogenetic signal in the residuals, so maybe we don’t care about phylogenetic signal in the variables? Unless there is a real need, don’t bother! You could visualise what is going on instead by adding colours to the tips of the phylogeny to represent the different categories. This should give you an idea about whether categories cluster in different clades or not. We could code our categories numerically then use \\(\\lambda\\) and K as usual. This is only suitable if the categories are ordered, and if the difference between each pair of categories can be considered equal. For example, a variable that has low, medium and high values could be coded as low = 1, medium = 2, and high = 3. Again this is not ideal, but will give you an answer. I’d avoid this if possible. We could recode these as binary variables and use D (Fritz and Purvis 2010). For example, creating a new variable called Aquatic, and coding each species as 0 = not aquatic; 1 = aquatic. This is probably the best solution. 5.4.1 D We can estimate D using the function phylo.d in the caper package. First we’d need to set up a binary (0,1) variable. Let’s look at Sex_dichromatism as this only has two categories already (Absent and Present). mydata %&gt;% group_by(Sex_dichromatism) %&gt;% summarise(n()) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 3 x 2 ## Sex_dichromatism `n()` ## &lt;fct&gt; &lt;int&gt; ## 1 Absent 150 ## 2 Present 24 ## 3 &lt;NA&gt; 36 There are 36 species without data for this variable. If we were doing something like PGLS (see next exercise), caper would be fine with this, but for phylo.d we can only work with data without NAs. To fix this, we can use filter to exclude the species with NAs, but we also want to remove these species from the tree. It’s easiest to go back to our treeplyr functions to do this. Let’s first go back to frogstuff, the combined object with our data and our tree in it, so we can exclude the species without Sex_dichromatism data, making frogstuff2. # Filter out species with no Sex_dichromatism data frogstuff2 &lt;- frogstuff %&gt;% filter(!is.na(Sex_dichromatism)) Now we can go back to our usual workflow, but using frogstuff2. Replace the removed species names column, save the data as a dataframe for later analyses, and save the tree. # Make a new column called tiplabel with the tip labels in it frogstuff2$dat$tiplabel &lt;- frogstuff2$phy$tip.label # Force mydata to be a data frame mydata &lt;- as.data.frame(frogstuff2$dat) # Save tree as mytree mytree &lt;- frogstuff2$phy We also need the variable Sex_dichromatism to be either 0 or 1. We can do this fairly easily using mutate to create a new variable called sex_di_binary. mydata &lt;- mydata %&gt;% # Make a new variable called sex_di_binary # which is Sex_dichromatism expressed as numbers # Absent = 1 and Present = 2. To make these 0 and 1 instead we just use -1 mutate(sex_di_binary = as.numeric(Sex_dichromatism) - 1) To use phylo.d we need the caper package. caper requires you to first combine the phylogeny and data into one object using the function comparative.data. This is similar to what we did with make.treedata, but it does some stuff that is particular to how caper works so we still need to do this here. Note that vcv = TRUE stores a variance covariance matrix of your tree (you will need this for the pgls function in the next exercise). na.omit = FALSE stops the function from removing species without data for all variables. warn.dropped = TRUE will tell you if any species are not in both the tree and the data and are therefore dropped from the comparative data object. frog &lt;- comparative.data(phy = mytree, data = mydata, names.col = tiplabel, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE) This function will give a warning telling you that some species have been dropped. Always make sure you check the list of dropped species is what you expected, as it often reveals typos in your species names, or mismatches in taxonomies used etc. You can view the dropped species using: frog$dropped$unmatched.rows ## character(0) This shows nothing because we already fixed the data so that all the species in the data are in the tree. frog$dropped$tips ## character(0) This also shows nothing because we already fixed the tree so that all the species in the tree are in the data. One last bit of prep required is that D cannot be estimated where trees have zero length branches. In 04-Preparation you may recall that we dealt with polytomies by replacing them with zero length branches using the ape function mutli2di. To remove the zero length branches we are going to use the opposite function: di2multi. This deletes all zero length branches and collapses them back into polytomies. frog$phy &lt;- di2multi(frog$phy) Now we are ready to to estimate D. # Estimate D Dsexdi &lt;- phylo.d(data = frog, names.col = tiplabel, binvar = sex_di_binary, permut = 1000) # Look at the output Dsexdi ## ## Calculation of D statistic for the phylogenetic structure of a binary variable ## ## Data : mydata ## Binary variable : sex_di_binary ## Counts of states: 0 = 150 ## 1 = 24 ## Phylogeny : mytree ## Number of permutations : 1000 ## ## Estimated D : 0.8709497 ## Probability of E(D) resulting from no (random) phylogenetic structure : 0.2 ## Probability of E(D) resulting from Brownian phylogenetic structure : 0.001 phylo.d estimates the D value, then tests the estimated D value for significant departure from random association and a Brownian evolution threshold model (see Primer and Fritz and Purvis (2010) for more details). Here D for Sex_dichromatism is 0.871. This is significantly different from the expectation under a Brownian threshold model (p = 0.001) but not significantly different from the trait being randomly assorted on the phylogeny (p = 0.2). So here we can say there is no significant phylogenetic signal in the trait. We can make a really quick plot to check we agree with that statement (never take the results of any analysis at face value). It doesn’t seem like sexual dichromatism (red text) is a trait that is particularly clustered within certain taxonomic groups, so seems that D is giving us a sensible answer. mycolours &lt;- c(&quot;black&quot;, &quot;red&quot;) plot(frog$phy, show.tip.label = TRUE, tip.color = mycolours[as.numeric(mydata$sex_di_binary)+1], no.margin = TRUE, cex = 0.4) # Add a legend legend(&quot;bottomleft&quot;, fill = mycolours, legend = c(&quot;Absent&quot;, &quot;Present&quot;), bty = &quot;n&quot;) Always carefully consider what variation in values of \\(\\lambda\\) and K and D across traits and groups really means. It may not tell you as much about your system as you think it does. Phylogenetic signal is only a pattern, not a process! 5.5 Summary You should now know how to estimate the phylogenetic signal of your variables using R. 5.6 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in the previous exercise which should save you some time). Then answer the following questions: What is \\(\\lambda\\) for log gestation length? (GestationLen_d) What is K for log gestation length? (GestationLen_d) What is D for social status? (SocialStatus) References "],["phylogenetic-generalised-least-squares-pgls-in-r.html", "Chapter 6 Phylogenetic Generalised Least Squares (PGLS) in R 6.1 Before you start 6.2 Preparation 6.3 Phylogenetic generalized least squares models (PGLS) 6.4 Common issues when running PGLS models in R 6.5 Summary 6.6 Practical exercises", " Chapter 6 Phylogenetic Generalised Least Squares (PGLS) in R The aims of this exercise are to learn how to use R to perform Phylogenetic Generalised Least Squares (PGLS) analyses. We will be using the evolution of eye size in frogs as an example. The data and modified tree come from Thomas et al. (2020), and the original tree comes from Feng et al. (2017). I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out Thomas et al. (2020)! 6.1 Before you start Open the 06-PGLS.RProj file in the 06-PGLS folder to open your R Project for this exercise. Make yourself a new R script for your code. You will also need to install the following packages: ape geiger treeplyr caper tidyverse 6.2 Preparation To begin we need to load the packages for this practical. # Load the packages library(ape) library(geiger) library(treeplyr) library(caper) library(tidyverse) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. It is important to do these things before beginning a phylogenetic comparative analysis, so let’s run through that code again here. # Read in the data frogdata &lt;- read_csv(&quot;data/frog-eyes.csv&quot;) # Check everything loaded corrected glimpse(frogdata) ## Rows: 215 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Aly… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alyt… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglos… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus… ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelli… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Fr… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.6000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.… ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.11666… To load the tree we will use read.nexus. # Read in the tree frogtree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Check it loaded correctly str(frogtree) ## List of 4 ## $ edge : int [1:426, 1:2] 215 216 217 218 219 220 221 222 223 224 ... ## $ edge.length: num [1:426] 0.166 0.114 0.102 0.4 0.133 ... ## $ Nnode : int 213 ## $ tip.label : chr [1:214] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary.tree(frogtree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(frogtree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(frogtree) ## [1] TRUE Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further. # Check whether the names match in the data and the tree check &lt;- name.check(phy = frogtree, data = frogdata, data.names = frogdata$tiplabel) # Look at check check ## $tree_not_data ## [1] &quot;Incilius_nebulifer_Bufonidae&quot; ## [2] &quot;Leptobrachella_bidoupensis_Megophryidae&quot; ## [3] &quot;Microhyla_fissipes_Microhylidae&quot; ## [4] &quot;Microhyla_marmorata_Microhylidae&quot; ## ## $data_not_tree ## [1] &quot;Gastrophryne_carolinensis_Microhylidae&quot; ## [2] &quot;Leptobrachella_dringi_Megophryidae&quot; ## [3] &quot;Megophrys_gerti_Megophryidae&quot; ## [4] &quot;Microhyla_pulverata_Microhylidae&quot; ## [5] &quot;Oreobates_quixensis_Strabomantidae&quot; Here all the excluded species are excluded because they are genuinely missing, not because of any typos, so we can move on. Next we combine the tree and data to exclude species that are not in both, using the treeplyr function make.treedata. # Combine and match the tree and data frogstuff &lt;- make.treedata(tree = frogtree, data = frogdata, name_column = &quot;tiplabel&quot;) # Look at the tree frogstuff$phy ## ## Phylogenetic tree with 210 tips and 209 internal nodes. ## ## Tip labels: ## Ascaphus_truei_Ascaphidae, Leiopelma_hochstetteri_Leiopelmatidae, Alytes_obstetricans_Alytidae, Discoglossus_pictus_Alytidae, Barbourula_busuangensis_Bombinatoridae, Bombina_orientalis_Bombinatoridae, ... ## ## Rooted; includes branch lengths. # Look at the data glimpse(frogstuff$dat) ## Rows: 210 ## Columns: 10 ## $ Binomial &lt;fct&gt; Ascaphus_truei, Leiopelma_hochstetteri, Alytes_… ## $ Family &lt;fct&gt; Ascaphidae, Leiopelmatidae, Alytidae, Alytidae,… ## $ Genus &lt;fct&gt; Ascaphus, Leiopelma, Alytes, Discoglossus, Barb… ## $ Adult_habitat &lt;fct&gt; Semiaquatic, Semiaquatic, Ground-dwelling, Grou… ## $ Life_history &lt;fct&gt; Free-living larvae, Free-living larvae, Free-li… ## $ Sex_dichromatism &lt;fct&gt; Absent, Absent, Absent, Absent, Absent, Absent,… ## $ SVL &lt;dbl&gt; 38.95000, 38.96667, 37.46667, 62.64000, 59.4750… ## $ mass &lt;dbl&gt; 6.000000, 5.333333, 6.666667, 24.400000, 24.250… ## $ rootmass &lt;dbl&gt; 1.809268, 1.740547, 1.869060, 2.888547, 2.73310… ## $ eyesize &lt;dbl&gt; 5.587500, 6.283333, 6.366667, 7.550000, 8.23750… Then we replace the removed species names column, and save the data as a data frame for later analyses. # Make a new column called tiplabel with the tip labels in it frogstuff$dat$tiplabel &lt;- frogstuff$phy$tip.label # Force mydata to be a data frame mydata &lt;- as.data.frame(frogstuff$dat) Finally we save the tree: # Save tree as mytree mytree &lt;- frogstuff$phy Note that is is possible to use the make.treedata object directly to run some analyses, but we have saved these separately here as many PCMs cannot work with this. Now we’re ready to run our analyses! 6.3 Phylogenetic generalized least squares models (PGLS) Much of the information below assumes that you are familiar with fitting and interpreting linear models (regressions, ANOVA, ANCOVA) in R using the function lm. If you aren’t I recommend taking a quick break to refamiliarise yourself with these models. It will make things much clearer. Even if you have never done these in R before, you should at least be familiar with the models, their assumptions and the kinds of results you might expect. Let’s investigate the relationship between eye size in frogs and their body size. Theory leads us to believe that bigger animals will have bigger eyes, but is this true in frogs? We can first quickly look at the phylogenetic non-independence/pseudoreplication on the graph by colouring the points by family. # Plot eyesize against body mass, coloured by family ggplot(mydata, aes(x = log(mass), y = log(eyesize), colour = Family)) + geom_point() + theme_bw() This is a bit messy because there are a lot of families, but note how certain families are clustered on the graph. It’s clear that close relatives are more similar than distant relatives. So we need to account for phylogenetic non-independence, both because of the statistical issues caused by this and because it’s a better way to model the biological reality of our question. We know frog species evolve from other frog species, and that close relatives will therefore be similar, so we should add this into our models. There are several ways of accounting for phylogenetic non-independence in your analyses. Here we will use phylogenetic generalized least squares (PGLS). Another popular earlier method is independent contrasts (PIC). This method is really similar to PGLS, in fact it is just a special kind of PGLS where \\(\\lambda\\) is equal to 1. PGLS offers some important advantages over independent contrasts. The model of trait evolution can be more flexible i.e., it can depart from a strict Brownian motion process (\\(\\lambda\\) or K = 1). Different scaling parameters (\\(\\lambda\\), \\(\\kappa\\), and \\(\\delta\\)) can be incorporated in the analysis, which can significantly improve the fit of the data to the model and thus also improve the estimation of the trait correlation. Another advantage of PGLS is that the intercept of the regression is not forced to be zero. See the Primer for more details on the theory underlying PICs and PGLS. 6.3.1 Fitting PGLS models in R To perform PGLS models in R, caper requires you to first combine the phylogeny and data into one object using the function comparative.data. This is similar to what we did with make.treedata, but it does some stuff that is particular to how caper works so we still need to do this here. Note that vcv = TRUE stores a variance covariance matrix of your tree (you will need this for the pgls function). na.omit = FALSE stops the function from removing species without data for all variables. warn.dropped = TRUE will tell you if any species are not in both the tree and the data and are therefore dropped from the comparative data object. Here we won’t drop any species because we already did this using make.treedata. frog &lt;- comparative.data(phy = mytree, data = mydata, names.col = tiplabel, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE) If you do need to drop species, this function will give a warning telling you that some species have been dropped. You can view the dropped species using: frog$dropped$tips ## character(0) frog$dropped$unmatched.rows ## character(0) Always make sure you check the list of dropped species is what you expected, it often reveals typos in your species names, or mismatches in taxonomies used etc. Here we already fixed this problem, so nothing is listed. See the 04-Preparation chapter for more details. The function for PGLS analyses in caper is pgls. To fit a model which uses the Maximum Likelihood (ML) estimate of \\(\\lambda\\) we use the following code: # Fit a PGLS model model.pgls &lt;- pgls(log(eyesize) ~ log(mass), data = frog, lambda = &quot;ML&quot;) To look at the output we use anova (in the same way as we would when fitting a model using lm): # Look at the model outputs anova(model.pgls) ## Analysis of Variance Table ## Sequential SS for pgls: lambda = 0.98, delta = 1.00, kappa = 1.00 ## ## Response: log(eyesize) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## log(mass) 1 58.595 58.595 906.82 &lt; 2.2e-16 *** ## Residuals 208 13.440 0.065 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 It’s always good to look at the output using anova first. This uses sequential sum of squares to tell you whether a model including your predictor variable(s) is a better fit than a model without your predictor variable(s). For a complex model with lots of predictors this is the easiest way to find out the answer to the question you were asking (this will become more obvious in the next example using two predictor variables). Here we asked “is there a significant effect of log(mass) on log(eyesize)?”. The answer is YES, there is a significant effect of log(mass) on log(eyesize). If we were reporting this result in a report/thesis/paper we would do it as follows: There was a significant effect of mass on eyesize (PGLS: F = 906.82, df = 1,208, p &lt; 0.001, \\(\\lambda\\) = 0.98). This is exactly how you would report the output of any non-phylogenetic linear model, except we also include the \\(\\lambda\\) value when reporting the PGLS results. We might also be interested in the model coefficients, i.e. the intercept and slope. To do this, just like we do for lm, we use summary: # Look at the model coefficients summary(model.pgls) ## ## Call: ## pgls(formula = log(eyesize) ~ log(mass), data = frog, lambda = &quot;ML&quot;) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.01708 -0.15412 0.00854 0.17623 0.82580 ## ## Branch length transformations: ## ## kappa [Fix] : 1.000 ## lambda [ ML] : 0.976 ## lower bound : 0.000, p = &lt; 2.22e-16 ## upper bound : 1.000, p = 0.092889 ## 95.0% CI : (0.924, NA) ## delta [Fix] : 1.000 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.0327690 0.1472023 7.016 3.157e-11 *** ## log(mass) 0.2774303 0.0092128 30.113 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2542 on 208 degrees of freedom ## Multiple R-squared: 0.8134, Adjusted R-squared: 0.8125 ## F-statistic: 906.8 on 1 and 208 DF, p-value: &lt; 2.2e-16 We’d report this in a paper/report/thesis as: There was a significant positive relationship between mass and eyesize (PGLS: slope \\(\\pm\\) SE = 0.277 \\(\\pm\\) 0.009, t = 30.113, df = 208, p &lt; 0.001, \\(\\lambda\\) = 0.976). Again this is exactly the same as we would do for lm without the phylogenetic component, except we also include the \\(\\lambda\\) value when reporting the PGLS results. Note that as well as the standard regression outputs, the summary output includes the estimated ML value of \\(\\lambda\\) (0.976) and p values from likelihood ratio tests showing whether the ML \\(\\lambda\\) is significantly different from 0 or 1. You may have also noticed \\(\\kappa\\) and \\(\\delta\\) in the PGLS output. \\(\\kappa\\) and \\(\\delta\\) are also tree transformations which can improve the fit of the data to the tree. It is possible to use pgls to optimise \\(\\kappa\\) or \\(\\delta\\) (using kappa = “ML” or delta = “ML” instead of lambda = “ML” in the code above). We will not cover this here. Optimizing more than one of these parameters at the same time is not advisable because it would be impossible to interpret the results! We can also plot the results as follows: ggplot(mydata, aes(x = log(mass), y = log(eyesize))) + geom_point() + geom_abline(slope = coefficients(model.pgls)[2], intercept = coefficients(model.pgls)[1]) + theme_bw() Note that coefficients(model.pgls) gives us the intercept coefficients(model.pgls)[2], and slope coefficients(model.pgls)[2] of the line, allowing us to use geom_abline to fit the line. # Check out the model coefficients (intercept and slope) coefficients(model.pgls) ## (Intercept) log(mass) ## 1.0327690 0.2774303 6.3.2 Model diagnostics for PGLS models You must always check model diagnostic plots whenever you fit a model in R to check that your data meet the assumptions of the model. Ideally you should do this BEFORE looking at anova or summary as if your assumptions are not met, then the model is useless and needs to be modified before you can use it to extract p values etc. The method for getting model diagnostics for PGLS is the same for linear models, independent contrasts and PGLS models (though the graphs are slightly different) - we just use the function plot. You might recall we also use plot to plot phylogenies and other things. plot is one of a set of clever functions in R that uses an ifelse statement to decide what kind of plot it should do. When you ask R to plot something, it first determines what class of object it is. It then chooses the correct version of plot for that class. In this case the function it is actually using to plot the model diagnostics for PGLS is plot.pgls. You might also have spotted that anova and summary work in the same way… To get model diagnostic plots for PGLS: # First make a plotting window with four panes as there are four plots par(mfrow = c(2, 2)) # Now plot the model diagnostics plot(model.pgls) # Return the plot window to one pane for later plotting par(mfrow = c(1, 1)) If you’ve no idea what these diagnostic plots are for I suggest reading up on this. Getting Started With R is a good place to start, but plots 2 and 3 at least should have been covered in whatever standard statistics course you’ve taken previously. In brief: In plot 1 (upper left-hand plot) you should not see any data with a studentized residual &gt; \\(\\pm\\) 3. Any species with such large residuals may overly influence the results of the regression. Often these are the result of measurement error associated with species pairs joined by very short branches. You should report results with and without these outliers included, to see how much of an impact they have on your results. In plot 2 (upper right-hand plot), the Normal Q-Q plot, the points should approximately fall on the line. This tests for normality of residuals, one of the assumptions of linear models. Note that Q-Q plots often look a bit messy, but unless you plan to use your PGLS model to predict values for your response variable outside of the range of the predictors used in your model (i.e. if you fitted a model of mass vs eyesize with mass ranging from 1g to 100g and then you wanted to use the model to predict eyesize when mass was 1000g) it isn’t too much of a problem. The other diagnostic plots are much more important. In plot 3 (lower left-hand plot), the Fitted versus Residuals plot, we hope to see a fairly random scattering of points, often referred to as a sky at night distribution. This diagnostic plot is related to the systematic component of the model - any pattern here (e.g. strong positive or negative slopes, or humped or U-shaped patterns) suggests that the model has not been correctly specified. This might reflect a missing variable or interaction term, or that you need to transform your variables. Or that you need a different kind of model entirely. In plot 4 (lower right-hand plot), the Fitted versus Observed plot, we should see a correlation among the observed values and fitted values in the model. This will vary depending on how good the model fit is. It takes practice to know what is “good”, “bad” and “acceptable” with these plots. Here I would say the plots above are fine. 6.3.3 Likelihood profiles for \\(\\lambda\\) in PGLS models You should also look at the likelihood profiles for branch length transformations in PGLS models using pgls.profile: # Create a likelihood profile of the lambda estimate lambda.profile &lt;- pgls.profile(model.pgls, &quot;lambda&quot;) # Plot the likelihood profile plot(lambda.profile) This graph shows the likelihood profile of \\(\\lambda\\) in our model. Ideally you want a line with an obvious peak/optimum, rather than a flat line which would suggest \\(\\lambda\\) could be anything. You can see that the optimum (the peak of the curve) is at 0.976 as estimated in our PGLS model. The dotted red lines are the 95% confidence intervals on \\(\\lambda\\) for our model. pgls.confint prints out these numbers in $ci.val if you want to know the exact numbers. # Extract the confidence intervals on lambda pgls.confint(model.pgls, &quot;lambda&quot;)$ci.val ## [1] 0.9237133 NA Note that because our \\(\\lambda\\) value is so close to 1, and this is the upper bound for \\(\\lambda\\) in a PGLS model, the upper confidence interval is NA. If you needed to report the upper and lower confidence intervals (and this is good practice if they cover a large range of numbers), you could report the upper confidence interval here as 1. If the opposite situation occurred for a \\(\\lambda\\) close to 0, you would use the lower confidence interval of 0. 6.3.4 A PGLS example with more than one predictor variable In reality we are often interested in fitting models with more than one predictor variable. In the case of our frog eye size example, we’ve shown that smaller frogs have smaller eyes than larger frogs, but we imagine that the habitat the frogs live in might also influence eye size. For example, frogs living underground might have smaller eyes for their body size compared to frogs living in trees because they don’t use their eyes as much (see (???) to see whether this is indeed the case!). We can fit a more complex model to test whether eye size is correlated with both mass and adult habitat as follows: # Fit a PGLS model model.pgls2 &lt;- pgls(log(eyesize) ~ log(mass) * as.factor(Adult_habitat), data = frog, lambda = &quot;ML&quot;) It may help some of you if I tell you this is a phylogenetic version of an ANCOVA (analysis of covariance), whereas our first example was a regression. Both are linear models. Two things to note. First, as with lm in R, * means fit each predictor as a main effect AND include the interaction between them too. log(mass) * as.factor(Adult_habitat) is actually shorthand for typing log(mass) + as.factor(Adult_habitat) + log(mass):as.factor(Adult_habitat). log(mass):as.factor(Adult_habitat) is the interaction between mass and habitat, shown with the :. Second, I’ve added as.factor in front of Adult_habitat. This is to get R to treat this variable as a factor with levels, rather than as either a numeric variable, or as character data. Here it is not strictly needed as R already thinks Adult_habitat is a factor, but it’s a good idea to make sure. Now we’ve fitted the model, we need to check the model diagnostic plots. If these are unsuitable then we need to rethink how we fit the model. # First make a plotting window with four panes as there are four plots par(mfrow = c(2, 2)) # Now plot the model diagnostics plot(model.pgls2) # Return the plot window to one pane for later plotting par(mfrow = c(1, 1)) And let’s check out the lambda profile too. # Create a likelihood profile of the lambda estimate lambda.profile &lt;- pgls.profile(model.pgls2, &quot;lambda&quot;) # Plot the likelihood profile plot(lambda.profile) These all look fine so we can move on… Let’s look at the anova outputs. anova(model.pgls2) ## Analysis of Variance Table ## Sequential SS for pgls: lambda = 0.93, delta = 1.00, kappa = 1.00 ## ## Response: log(eyesize) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## log(mass) 1 44.771 44.771 1084.2494 &lt; 2.2e-16 ## as.factor(Adult_habitat) 5 2.436 0.487 11.8005 5.335e-10 ## log(mass):as.factor(Adult_habitat) 5 0.604 0.121 2.9275 0.01422 ## Residuals 198 8.176 0.041 ## ## log(mass) *** ## as.factor(Adult_habitat) *** ## log(mass):as.factor(Adult_habitat) * ## Residuals ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 OK great, this output is fairly easy to read (compared to the summary which we will look at in a bit!). The first row, labelled log(mass) tells us that the main effect of log(mass) is significant (p &lt; 0.001), i.e. log(mass) is significantly correlated with log(eyesize). It doesn’t tell us anything about direction (positive or negative) of the correlation, but we can do a quick plot to work this out: ggplot(mydata, aes(x = log(mass), y = log(eyesize))) + geom_point() + theme_bw() The plot clearly shows that as body size increases so does eye size (we already knew this from our first model above). The second row, labelled as.factor(Adult_habitat) tells us that the main effect of Adult habitat is also significant (p &lt; 0.001), i.e. Adult_habitat is significantly correlated with log(eyesize). Again we can do a quick plot to work to see which habitats are different… ggplot(mydata, aes(x = Adult_habitat, y = log(eyesize))) + geom_boxplot() + theme_bw() Eye size is smallest, on average, in fossorial (burrowing) frogs. That fits with what we know about burrowing animals - they tend to have reduced eyes (think of moles!). Finally the last row labelled log(mass):as.factor(Adult_habitat) tells us that the interaction between mass and habitat is significant (p = 0.014). This means that the relationship (i.e. the slope in a plot) between log(mass) and log(eyesize) varies in relation to Adult_habitat. We can look at this with another quick plot. ggplot(mydata, aes(x = log(mass), y = log(eyesize), colour = Adult_habitat)) + geom_point() + geom_smooth(method = &#39;lm&#39;, se = FALSE, formula = &#39;y ~ x&#39;) + theme_bw() We can see that the slope for fossorial (burrowing) species is shallower than for other species, suggesting that eye size increases more slowly with increasing mass in that group. I used geom_smooth(method = ‘lm’, se = FALSE) in the code above to get a quick idea of what the slopes look like using an lm. These slopes won’t be exactly the same in the PGLS model, but it gives us an idea of what is going on. Do not use geom_smooth to draw regression lines in your reports/papers/thesis. The function is for data exploration only and does not give the correct slope/confidence interval unless your models is very simple. We can get the correct intercepts and slopes for each of these lines using the summary function and our PGLS model, see below. I showed you the plots and anova output first because, as you’ll see below, summary outputs get complicated fast! summary(model.pgls2) ## ## Call: ## pgls(formula = log(eyesize) ~ log(mass) * as.factor(Adult_habitat), ## data = frog, lambda = &quot;ML&quot;) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.70184 -0.11053 0.01051 0.13012 0.68947 ## ## Branch length transformations: ## ## kappa [Fix] : 1.000 ## lambda [ ML] : 0.931 ## lower bound : 0.000, p = &lt; 2.22e-16 ## upper bound : 1.000, p = 0.0027911 ## 95.0% CI : (0.827, 0.985) ## delta [Fix] : 1.000 ## ## Coefficients: ## Estimate Std. Error ## (Intercept) 1.063339 0.168677 ## log(mass) 0.237742 0.037012 ## as.factor(Adult_habitat)Fossorial 0.108237 0.245771 ## as.factor(Adult_habitat)Ground-dwelling -0.018248 0.136761 ## as.factor(Adult_habitat)Scansorial 0.081581 0.139220 ## as.factor(Adult_habitat)Semiaquatic 0.123482 0.147832 ## as.factor(Adult_habitat)Subfossorial -0.150782 0.139996 ## log(mass):as.factor(Adult_habitat)Fossorial -0.114428 0.073321 ## log(mass):as.factor(Adult_habitat)Ground-dwelling 0.056417 0.039114 ## log(mass):as.factor(Adult_habitat)Scansorial 0.047165 0.042531 ## log(mass):as.factor(Adult_habitat)Semiaquatic 0.018215 0.042324 ## log(mass):as.factor(Adult_habitat)Subfossorial 0.087142 0.042066 ## t value Pr(&gt;|t|) ## (Intercept) 6.3040 1.849e-09 *** ## log(mass) 6.4234 9.696e-10 *** ## as.factor(Adult_habitat)Fossorial 0.4404 0.6601 ## as.factor(Adult_habitat)Ground-dwelling -0.1334 0.8940 ## as.factor(Adult_habitat)Scansorial 0.5860 0.5586 ## as.factor(Adult_habitat)Semiaquatic 0.8353 0.4046 ## as.factor(Adult_habitat)Subfossorial -1.0770 0.2828 ## log(mass):as.factor(Adult_habitat)Fossorial -1.5606 0.1202 ## log(mass):as.factor(Adult_habitat)Ground-dwelling 1.4424 0.1508 ## log(mass):as.factor(Adult_habitat)Scansorial 1.1090 0.2688 ## log(mass):as.factor(Adult_habitat)Semiaquatic 0.4304 0.6674 ## log(mass):as.factor(Adult_habitat)Subfossorial 2.0715 0.0396 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2032 on 198 degrees of freedom ## Multiple R-squared: 0.854, Adjusted R-squared: 0.8459 ## F-statistic: 105.3 on 11 and 198 DF, p-value: &lt; 2.2e-16 If you’re unfamiliar with these kinds of outputs it’s worth taking this slowly. Note that this is exactly the same as interpreting the output of a non-phylogenetic ANCOVA fitted using lm. The first row, labelled (Intercept), gives the intercept for the Adult_habitat that is first alphabetically. The row labelled log(mass) is the slope for the Adult_habitat that is first alphabetically. In this case that’s the Aquatic habitat (if you scroll back up to the figure with the different slopes you’ll see that it’s the first alphabetically, and also because of this it’s the only one not labelled in the output above). All of the other intercepts and slopes are treatment contrasts. Rather than the intercepts and slopes themselves, R reports the difference between the Adult_habitat in question and the Aquatic habitat (the first alphabetically). So the intercept for the fossorial frogs (as.factor(Adult_habitat)Fossorial) is… 1.063339 + 0.108237 ## [1] 1.171576 And the slope for the fossorial frogs (log(mass):as.factor(Adult_habitat)Fossorial) is… 0.237742 + -0.114428 ## [1] 0.123314 In some cases the exact numbers in the summary table will be important, but in most cases I’d report the results from a model like this using just the anova output, plus a nice figure that shows the information in the summary output much more clearly than copying out all these numbers. I might report these results like this (or if I had lots of models I would put the figures into a table). Mass, adult habitat and the interaction between them, were all significantly correlated with eye size (PGLS: \\(\\lambda\\) = 0.976; mass: F = 1084, df = 1, 198, p &lt; 0.001; habitat: F = 11.80, df = 5,198, p &lt; 0.001; interaction: F = 2.938, df = 5,198, p = 0.014; Figure 3). 6.4 Common issues when running PGLS models in R My example data are designed to work easily, but when you use your own data you may come across a couple of common errors. I therefore list these below. 6.4.1 Optim errors Sometimes you will find that pgls will not work and you get an optim error. This generally happens when the lambda profile is really flat, and the model is getting stuck near one of the bounds. To fix this error you need to change the bounds (i.e. upper and lower values) on the parameter being optimized, in this case \\(\\lambda\\). It usually seems to be the lower bound which is the issue. Just change the lower bound of \\(\\lambda\\) to something a little bigger than 1e-6 (the default lower bound) until it works. For example: # Fit PGLS model with a higher lower bound on lambda model.pgls2 &lt;- pgls(log(eyesize) ~ log(mass), data = frog, lambda = &quot;ML&quot;, bounds = list(lambda = c(1e-05, 1))) 6.4.2 Big problems with small datasets You will often find strange \\(\\lambda\\) profiles when you don’t have a lot of species in your data, because \\(\\lambda\\) has very low power to detect phylogenetic signal for less than 20-30 data points (Freckleton, Harvey, and Pagel 2002). This means that using PGLS on small datasets is tricky - you almost always get ML \\(\\lambda\\) of zero but the \\(\\lambda\\) profile will show a pretty flat likelihood surface. Unfortunately people often forget to look at the \\(\\lambda\\) profile so erroneously conclude that there is no phylogenetic autocorrelation in their data. Generally I’d say don’t use small datasets, however, this seems unavoidable in some fields. Therefore my advice is to (only in this situation!) ignore one of Rob Freckleton’s deadly sins (Freckleton 2009) and report the results from a non-phylogenetic lm model (equivalent of PGLS with \\(\\lambda\\) = 0) and also report the results from a PGLS model with \\(\\lambda\\) set to 1 (equivalent to independent contrasts). This is not ideal but it’s the best solution at present if collecting more data is not an option. To set \\(\\lambda\\) to 1 you just replace “ML” with 1: # Fit PGLS model with lambda set to 1 model.pgls3 &lt;- pgls(log(eyesize) ~ log(mass), data = frog, lambda = 1) 6.5 Summary You should now know how to perform a PGLS analysis in R using the package caper. 6.6 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Let’s investigate the relationship between gestation length in Primates and their body size. Theory leads us to believe that bigger mammals have longer gestation lengths (compare mice to elephants), but is this true in Primates? Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit a PGLS model to investigate the relationship between log gestation length (y = log(GestationLen_d)) and log body size (x = log(AdultBodyMass_g)) in Primates (HINT: You may find this gives you an OPTIM error, see above. You can solve it using bounds = list(lambda = c(0.01, 1)) as shown in the section on optim errors above). Don’t forget to look at the model diagnostics! Then answer the following questions. What is the maximum likelihood estimate of \\(\\lambda\\) in the model? What are the confidence intervals on the maximum likelihood estimate of \\(\\lambda\\). How would you interpret these? Plot the \\(\\lambda\\) profile for the the maximum likelihood estimate of \\(\\lambda\\). What does it look like? Is there a significant relationship between log gestation length and log body size? What is the slope of this relationship? References "],["macroevolutionary-models-for-continuous-traits.html", "Chapter 7 Macroevolutionary models for continuous traits 7.1 Before you start 7.2 Preparation 7.3 Models of evolution for continuous traits 7.4 Summary 7.5 Practical exercises", " Chapter 7 Macroevolutionary models for continuous traits The aims of this exercise are to learn how to use R to fit macroevolutionary models in R to continuous traits. We will be using the evolution of head shape in natricine snakes as an example. The data and modified tree come from DEEPAK [CITE PAPER], and the tree comes from DEEPAK [CITE PAPER]. I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out DEEPAK [CITE PAPER]! 7.1 Before you start Open the 07-ModelsContinuous.RProj file in the 07-ModelsContinuous folder to open your R Project for this exercise. Make yourself a new R script for your code. You will also need to install the following packages: ape geiger treeplyr 7.2 Preparation To begin we need to load the packages for this practical. # Load the packages library(ape) library(geiger) library(treeplyr) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. It is important to do these things before beginning a phylogenetic comparative analysis, so let’s run through that code again here. # Read in the data snakedata &lt;- read_csv(&quot;data/snake-heads.csv&quot;) # Check everything loaded corrected glimpse(snakedata) ## Rows: 206 ## Columns: 9 ## $ Species &lt;chr&gt; &quot;Adelophis_foxi&quot;, &quot;Afronatrix_anoscopus_2&quot;, &quot;Am… ## $ Ecomorph &lt;chr&gt; &quot;Burrowing&quot;, &quot;Aquatic&quot;, &quot;Terrestrial&quot;, &quot;Terrest… ## $ Diet &lt;chr&gt; &quot;annelids&quot;, &quot;aquatic generalist&quot;, &quot;anurans&quot;, &quot;a… ## $ ReproductiveMode &lt;chr&gt; &quot;Viviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Ovipar… ## $ HeadLength &lt;dbl&gt; 12.560, 25.100, 15.060, 20.105, 19.950, 18.810,… ## $ HeadWidth &lt;dbl&gt; 6.60, 15.80, 7.82, 9.13, 10.32, 9.82, 8.39, 11.… ## $ HeadHeight &lt;dbl&gt; 5.43, 10.30, 5.40, 6.61, 7.56, 5.80, 6.40, 8.70… ## $ EyeDistance &lt;dbl&gt; 4.01, 7.40, 4.85, 5.85, 5.84, 5.42, 6.00, 6.05,… ## $ TotalLength &lt;dbl&gt; 105, 194, 106, 185, 165, 155, NA, 163, 130, 309… To load the tree we will use read.nexus. # Read in the tree snaketree &lt;- read.nexus(&quot;data/snake-tree.nex&quot;) # Check it loaded correctly str(snaketree) ## List of 4 ## $ edge : int [1:496, 1:2] 250 251 252 253 254 255 256 257 258 259 ... ## $ edge.length: num [1:496] 4.695 2.225 0.587 0.307 0.832 ... ## $ Nnode : int 248 ## $ tip.label : chr [1:249] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_1&quot; &quot;Rhabdophis_nuchalis_2&quot; &quot;Rhabdophis_adleri_1&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary.tree(snaketree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(snaketree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(snaketree) ## [1] TRUE Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further. Note that in this dataset the species names are in the column Species. # Check whether the names match in the data and the tree check &lt;- name.check(phy = snaketree, data = snakedata, data.names = snakedata$Species) # Look at check check ## $tree_not_data ## [1] &quot;Afronatrix_anoscopus_1&quot; ## [2] &quot;Afronatrix_anoscopus_3&quot; ## [3] &quot;Aspidura_ravani&quot; ## [4] &quot;Atretium_schistosum_1&quot; ## [5] &quot;Blythia_hmuifang&quot; ## [6] &quot;Fowlea_piscator_1&quot; ## [7] &quot;Fowlea_piscator_3&quot; ## [8] &quot;Fowlea_piscator_4&quot; ## [9] &quot;Hebius_andreae&quot; ## [10] &quot;Hebius_atemporale_2&quot; ## [11] &quot;Hebius_atemporale_3&quot; ## [12] &quot;Hebius_atemporale_4&quot; ## [13] &quot;Hebius_bitaeniatum_1&quot; ## [14] &quot;Hebius_bitaeniatum_2&quot; ## [15] &quot;Hebius_bitaeniatum_3&quot; ## [16] &quot;Hebius_boulengeri_1&quot; ## [17] &quot;Hebius_cf._boulengeri&quot; ## [18] &quot;Hebius_concelarum&quot; ## [19] &quot;Hebius_craspedogaster_1&quot; ## [20] &quot;Hebius_craspedogaster_3&quot; ## [21] &quot;Hebius_deschauenseei_1&quot; ## [22] &quot;Hebius_deschauenseei_2&quot; ## [23] &quot;Hebius_ishigakiensis&quot; ## [24] &quot;Hebius_khasiense_2&quot; ## [25] &quot;Hebius_khasiense_3&quot; ## [26] &quot;Hebius_leucomystax&quot; ## [27] &quot;Hebius_octolineatum_1&quot; ## [28] &quot;Hebius_octolineatum_2&quot; ## [29] &quot;Hebius_optatum_2&quot; ## [30] &quot;Hebius_popei_1&quot; ## [31] &quot;Hebius_pryeri_1&quot; ## [32] &quot;Hebius_sangzhiensis&quot; ## [33] &quot;Hebius_sauteri_2&quot; ## [34] &quot;Hebius_sp&quot; ## [35] &quot;Hebius_sp1&quot; ## [36] &quot;Hebius_sp2&quot; ## [37] &quot;Hebius_sp4&quot; ## [38] &quot;Hebius_taronense&quot; ## [39] &quot;Hebius_venningi_1&quot; ## [40] &quot;Hebius_venningi_3&quot; ## [41] &quot;Hebius_venningi_4&quot; ## [42] &quot;Hebius_yanbianensis&quot; ## [43] &quot;Herpetoreas_burbrinki&quot; ## [44] &quot;Limnophis_branchi&quot; ## [45] &quot;Natriciteres_olivacea_2&quot; ## [46] &quot;Natriciteres_sylvatica_2&quot; ## [47] &quot;Natriciteres_sylvatica_3&quot; ## [48] &quot;Natrix_helvatica&quot; ## [49] &quot;Natrix_tessellata_1&quot; ## [50] &quot;Opisthotropis_cheni&quot; ## [51] &quot;Opisthotropis_daovantieni&quot; ## [52] &quot;Opisthotropis_durandi&quot; ## [53] &quot;Opisthotropis_guangxiensis&quot; ## [54] &quot;Opisthotropis_haihaensis&quot; ## [55] &quot;Opisthotropis_hungtai&quot; ## [56] &quot;Opisthotropis_kuatunensis&quot; ## [57] &quot;Opisthotropis_laui&quot; ## [58] &quot;Opisthotropis_maculosa&quot; ## [59] &quot;Opisthotropis_maxwelli&quot; ## [60] &quot;Opisthotropis_shenzhenensis&quot; ## [61] &quot;Opisthotropis_voquyi&quot; ## [62] &quot;Opisthotropis_zhaoermii&quot; ## [63] &quot;Rhabdophis_adleri_1&quot; ## [64] &quot;Rhabdophis_adleri_2&quot; ## [65] &quot;Rhabdophis_callichromus&quot; ## [66] &quot;Rhabdophis_formosanus&quot; ## [67] &quot;Rhabdophis_guangdongensis&quot; ## [68] &quot;Rhabdophis_nuchalis_1&quot; ## [69] &quot;Rhabdophis_nuchalis_2&quot; ## [70] &quot;Rhabdophis_nuchalis_pentasupralabialis&quot; ## [71] &quot;Rhabdophis_pentasupralabialis&quot; ## [72] &quot;Rhabdophis_swinhonis_2&quot; ## [73] &quot;Thamnophis_exsul_1&quot; ## [74] &quot;Thamnophis_gigas&quot; ## [75] &quot;Thamnophis_mendax&quot; ## [76] &quot;Thamnophis_nigronuchalis&quot; ## [77] &quot;Thamnophis_ordinoides&quot; ## [78] &quot;Thamnophis_scalaris_1&quot; ## [79] &quot;Thamnophis_scaliger_2&quot; ## [80] &quot;Trachischium_apteii&quot; ## [81] &quot;Trachischium_monticola_2&quot; ## [82] &quot;Trimerodytes_praemaxillaris&quot; ## [83] &quot;Trimerodytes_yapingi&quot; ## [84] &quot;Tropidonophis_dahlii&quot; ## [85] &quot;Tropidonophis_dendrophiops&quot; ## [86] &quot;Tropidonophis_multiscutellatus_2&quot; ## [87] &quot;Tropidonophis_statisticus_2&quot; ## ## $data_not_tree ## [1] &quot;Amphiesma_stolatum&quot; ## [2] &quot;Amphiesma_stolatum_WII&quot; ## [3] &quot;Aspidura_brachyorrhos&quot; ## [4] &quot;Aspidura_copei&quot; ## [5] &quot;Fowlea_flavipunctatus&quot; ## [6] &quot;Fowlea_melanzostus&quot; ## [7] &quot;Hebius_bitaeniatum_4&quot; ## [8] &quot;Hebius_celabicus&quot; ## [9] &quot;Hebius_clerki&quot; ## [10] &quot;Hebius_flavifrons&quot; ## [11] &quot;Hebius_groundwateri&quot; ## [12] &quot;Hebius_inas&quot; ## [13] &quot;Hebius_petersi&quot; ## [14] &quot;Hebius_sanguinea&quot; ## [15] &quot;Hebius_sarasinorum&quot; ## [16] &quot;Hebius_sarawacensis&quot; ## [17] &quot;Hebius_vibakari_2&quot; ## [18] &quot;Hebius_vibakari_ruthveni&quot; ## [19] &quot;Herpetoreas_sieboldi&quot; ## [20] &quot;Hydrablabes_periops&quot; ## [21] &quot;Hydrablabes_prafrontalis&quot; ## [22] &quot;Hydraethiops_laevis&quot; ## [23] &quot;Isanophis_boonsongi&quot; ## [24] &quot;Opisthotropis_spenceri&quot; ## [25] &quot;Paratapinophis_praemaxillaris&quot; ## [26] &quot;R_lineatus&quot; ## [27] &quot;Rhabdophis_barbouri&quot; ## [28] &quot;Rhabdophis_chrysargoides&quot; ## [29] &quot;Rhabdophis_chrysargos&quot; ## [30] &quot;Smithophis_sp&quot; ## [31] &quot;Storeria_hidalgoensis&quot; ## [32] &quot;Thamnophis_elegans_lineolata&quot; ## [33] &quot;Thamnophis_rossmani&quot; ## [34] &quot;Thamnophis_rufipunctatus_unilabialis&quot; ## [35] &quot;Trachischium_susantai&quot; ## [36] &quot;Tropidonophis_celebicus&quot; ## [37] &quot;Tropidonophis_elongatus&quot; ## [38] &quot;Tropidonophis_halmahericus&quot; ## [39] &quot;Tropidonophis_hypomelas&quot; ## [40] &quot;Tropidonophis_mairii_brongersmai&quot; ## [41] &quot;Tropidonophis_mcdowelli&quot; ## [42] &quot;Tropidonophis_novaeguinea&quot; ## [43] &quot;Tropidonophis_parkeri&quot; ## [44] &quot;Tropidonophis_truncatus&quot; There are a lot of species in the tree that are not in the data and vice versa! But (you’ll have to take my word for it!) all the excluded species are excluded because they are genuinely missing, not because of any typos, so we can move on. Having a lot of species missing from trees and data is not uncommon. To build trees we usually need molecular data which may be absent for newly collected specimens, or for older specimens. Likewise, it can be really difficult to gather all the data required for all of the species in a group - we know very little about the natural history of some species for example. This is nothing to panic about in your own datasets, but knowing which species are in the tree could help you target species to collate extra data for. Next we combine the tree and data to exclude species that are not in both, using the treeplyr function make.treedata. # Combine and match the tree and data snakestuff &lt;- make.treedata(tree = snaketree, data = snakedata, name_column = &quot;Species&quot;) # Look at the tree snakestuff$phy ## ## Phylogenetic tree with 162 tips and 161 internal nodes. ## ## Tip labels: ## Rhabdophis_leonardi, Rhabdophis_nuchalis_3, Rhabdophis_swinhonis_1, Rhabdophis_nigrocinctus, Rhabdophis_tigrinus, Rhabdophis_tigrinus_lateralis, ... ## ## Rooted; includes branch lengths. # Look at the data glimpse(snakestuff$dat) ## Rows: 162 ## Columns: 8 ## $ Ecomorph &lt;fct&gt; Semiaquatic, Terrestrial, Semiaquatic, Terrestr… ## $ Diet &lt;fct&gt; unknown, generalist, anurans, generalist, gener… ## $ ReproductiveMode &lt;fct&gt; Oviparous, Oviparous, Oviparous, Oviparous, Ovi… ## $ HeadLength &lt;dbl&gt; 25.640, 14.590, 18.030, 26.685, 23.760, 34.135,… ## $ HeadWidth &lt;dbl&gt; 13.72, 7.42, 8.58, 14.62, 13.94, 19.33, 11.79, … ## $ HeadHeight &lt;dbl&gt; 10.81, 5.79, 6.68, 9.83, 8.88, 12.90, 8.46, 8.6… ## $ EyeDistance &lt;dbl&gt; 8.16, 5.17, 5.74, 9.50, 7.89, 10.39, 8.27, 8.43… ## $ TotalLength &lt;int&gt; 120, 79, 123, 262, 132, 199, 226, 224, NA, NA, … Overall we have 162 species in the data and the tree. Then we replace the removed species names column, and save the data as a data frame for later analyses. # Make a new column called tiplabel with the tip labels in it snakestuff$dat$tiplabel &lt;- snakestuff$phy$tip.label # Force mydata to be a data frame mydata &lt;- as.data.frame(snakestuff$dat) Finally we save the tree: # Save tree as mytree mytree &lt;- snakestuff$phy Now we’re ready to run our analyses! 7.3 Models of evolution for continuous traits For fitting models of evolution to continuous data we will use the fitContinuous function in the R package geiger. fitContinuous is a likelihood based method, so the output will give the maximum likelihood (ML) estimates of the parameters. Bayesian methods are becoming preferred for these kinds of analyses and fitContinuousMCMC will perform these analyses, but I’m not going to cover it here. As an example, let’s look at the evolution of head length in our snake data. Snake head shape is closely related to the ecology of the species, so we are interested in understanding how it evolves. These first analyses are quite simple, but would be the first step in a more detailed analysis. 7.3.1 loook at the data???? 7.3.2 Fitting the Brownian motion and OU models of evolution using fitContinuous We’ll fit two commonly used evolutionary models to the data; the Brownian motion (BM) model and the single peak Ornstein-Uhlenbeck (OU) model. As a quick reminder, the BM model is a so called “random walk” model where traits change gradually through time. The model has two parameters, the Brownian rate parameter, \\(\\sigma^2\\) and the state of the root at time zero, \\(z(0)\\). The OU model is a random walk where trait values are pulled back towards some “optimal” value with an attraction strength proportional to the “rubber-band” parameter \\(\\alpha\\). The OU model has four parameters the Brownian rate parameter, \\(\\sigma^2\\), the state of the root at time zero, \\(z(0)\\), the long-term mean, \\(\\mu\\), and the strength of evolutionary force that returns traits back towards the long-term mean if they evolve away from it, \\(\\alpha\\). If \\(\\alpha\\) is close to zero then evolution is approximately Brownian. For more details on these models please see the Primer. fitContinuous can also fit several other models. For more details look at the help file by typing: ?fitContinuous We are going to use the package geiger to fit models in this exercise, which means there is an important additional preparation step that you may remember from when we used the package phytools and the function phylosig when were looking at phylogenetic signal in 05-PhyloSignal. At this point you may be thinking, argh why can’t all R packages work in the same way? This is because different packages were written by different people. We all have different programming styles, preferences and biases (some people really hate the tidyverse and ggplot2 for example!) and these feed into the code we write. My advice is to follow these tutorials (and others) carefully, and don’t worry about the differences too much. To put a positive spin on this, yes there may be lots of different ways to do things in R but at least they exist! Back in the day people published methods without the accompanying R packages. If you were lucky you might get some FORTRAN or C++ or C code, but generally you’d be expected to program the new methods yourself if you wanted to use them. Dealing with the idiosyncrasies of different people’s R packages is a breeze compared to that! The first thing we need to do is to create an object in R that only contains the variable required, and the species names (so we can match it up to the tree). We can use the function pull to extract just the head length values, and we can log transform all these numbers using log if we want to work with log head length values. # Create logHL containing just log head length length values logHL &lt;- log(pull(mydata, HeadLength)) # Look at the first few rows head(logHL) ## [1] 3.244154 2.680336 2.892037 3.284102 3.168003 3.530323 Notice that this is currently just a long list of numbers. We can then name these values with the species names from mydata using the function names. Note that this requires the trait data is in the same order as the tree tip labels, but luckily make.treedata does this automatically. # Give log head length names = species names at the tips of the phylogeny names(logHL) &lt;- mydata$tiplabel # Look at the first few rows head(logHL) ## Rhabdophis_leonardi Rhabdophis_nuchalis_3 ## 3.244154 2.680336 ## Rhabdophis_swinhonis_1 Rhabdophis_nigrocinctus ## 2.892037 3.284102 ## Rhabdophis_tigrinus Rhabdophis_tigrinus_lateralis ## 3.168003 3.530323 Now we have a list of values with associated species names. To fit the Brownian model we can then use the code below. BM &lt;- fitContinuous(mytree, logHL, model = c(&quot;BM&quot;)) To look at the output type: BM ## GEIGER-fitted comparative model of continuous data ## fitted &#39;BM&#39; model parameters: ## sigsq = 0.036973 ## z0 = 2.854226 ## ## model summary: ## log-likelihood = -153.103148 ## AIC = 310.206296 ## AICc = 310.281767 ## free parameters = 2 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 100 ## frequency of best fit = 1.00 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates The maximum likelihood estimates of the model parameters are found near the top of the output. In a Brownian motion (BM) model we estimate the Brownian rate parameter, \\(\\sigma^2\\) or sigsq in the output above, which is 0.037 and the value of the trait at the root of the tree, \\(z(0)\\) or z0 in the output above, which is 2.854. Other useful things in the output are the maximum-likelihood estimate of the model (log-likelihood), the Akaike Information Criterion (AIC), sample-size corrected AIC (AICc) and the number of model parameters (free parameters) also known as \\(k\\) in the literature. We will return to the AIC values below. To fit an Ornstein-Uhlenbeck model we only need to change the model in the formula we used above: OU &lt;- fitContinuous(mytree, logHL, model = c(&quot;OU&quot;)) ## Warning in fitContinuous(mytree, logHL, model = c(&quot;OU&quot;)): ## Parameter estimates appear at bounds: ## alpha This gives us a warning message (it doesn’t say Error so it’s not an error message). This means the analysis has run, but there’s something we should be aware of. This warning is telling us something about the bounds of the parameter estimates, specifically the alpha or “rubber-band” parameter. What’s the deal with bounds? These BM and OU models are fitted using Maximum Likelihood. We talk more about this in the Primer. But as a quick reminder, to get the Maximum Likelihood for a model, we need to find the values of the parameters that maximise the likelihood function. Rather than trying every possible combination of parameter values we instead use some kind of optimisation procedure. Optimisations are often described in terms of hills and valleys. If you’re in the mountains looking for the highest peak, you could wander around the whole area, recording the height at each point, or we can make the process faster by always walking towards higher ground. If we did this we’d spend less time in the valleys and more time climbing towards the highest peaks. This is optimisation. To prevent us from spending lots of time looking in the wrong place, we could also define the boundaries of our search area, so we only look within a certain region. Our models do this by having bounds on the parameter values. So, for example, instead of looking at models with all possible values of \\(\\alpha\\) in an OU model, fitContinuous constrains the values of \\(\\alpha\\) to be between exp(-500) and exp(1). To fix this issue we just change the bounds and refit the model. If you check out the help file for fitContinuous it tells us: Default bounds are alpha = c(min = exp(-500), max = exp(1)) We can see what the value of alpha was in the model we fitted as follows: OU$opt$alpha ## [1] 2.718282 This is the same as exp(1). So alpha is the same as the upper bound, meaning that is the bound we need to change. We can do that as follows: OU &lt;- fitContinuous(mytree, logHL, model = c(&quot;OU&quot;), bounds = list(alpha = c(exp(-500), 10))) We don’t get any kind of message this time so it looks like we fixed the problem! To look at the output type: OU ## GEIGER-fitted comparative model of continuous data ## fitted &#39;OU&#39; model parameters: ## alpha = 9.013855 ## sigsq = 2.512294 ## z0 = 2.968916 ## ## model summary: ## log-likelihood = -69.215721 ## AIC = 144.431442 ## AICc = 144.583341 ## free parameters = 3 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 39 ## frequency of best fit = 0.39 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates As for Brownian motion, the maximum likelihood estimates of the model parameters are found near the top of the output. In an Ornstein-Uhlenbeck (OU) model we estimate the Brownian rate parameter, \\(\\sigma^2\\) or sigsq in the output above, the value of the trait at the root of the tree, \\(z(0)\\) or z0 in the output above, and the “rubber-band” parameter, \\(\\alpha\\) or alpha in the output above. As alpha = 9.014 here, it suggests that there is evolution towards a particular head length. I mentioned above that the OU model has four parameters, \\(\\sigma^2\\), \\(z(0)\\), \\(\\mu\\) and \\(\\alpha\\). But only three appear on the output above. This is because fitContinuous only estimates \\(\\sigma^2\\), \\(z(0)\\), and \\(\\alpha\\). It does not estimate \\(\\mu\\) but in this implementation of the model, \\(\\mu\\) is equivalent to \\(X(0)\\). Sometimes these models will tell you they have not converged. This just means the model has failed to find the optimal values for the parameters. This is most common in the OU model, and tends to happen when the likelihood surface for the parameter has long flat ridges that cause the likelihood search to get “stuck” and unable to find the peak (in our mountain climbing analogy it’s like getting stuck in a massive flat valley when it’s foggy and you can’t see the mountains around you to work out how to get to higher ground). If this happens, try changing the bounds on the alpha parameter. Moving the lower bound away from zero can help, as can increasing the upper bound. 7.3.3 Comparing models of evolution using AIC Often we want to know which of the models fits our variable best. We can use fitContinuous to fit the models we are interested in and can then compare them using AIC. We can extract the AICs from the models we fitted above as follows: BM$opt$aic ## [1] 310.2063 OU$opt$aic ## [1] 144.4314 The “best” model is the one with the smallest AIC, in this case the OU model. There is much debate about how big of a difference in AIC values can be classed as substantial improvement to a model fit (it usually ranges from 2-10 AIC units). Generally we use 4 units, so OU fits this data substantially better than BM. Alternatively we can use \\(\\Delta\\)AIC or AIC weights to compare our models using the following code and the geiger function aicw: aic.scores &lt;- setNames(c(BM$opt$aic, OU$opt$aic), c(&quot;BM&quot;,&quot;OU&quot;)) aicw(aic.scores) ## fit delta w ## BM 310.2063 165.7749 1.005653e-36 ## OU 144.4314 0.0000 1.000000e+00 aicw outputs the AIC (fit), \\(\\Delta\\)AIC (delta) and AIC weights (w) for each of the models we fitted. The best model is the model with \\(\\Delta\\)AIC = 0 or with AICw closest to 1. Using \\(\\Delta\\)AIC we can conclude that the OU model is the best fit to the data. 7.4 Summary You should now know how to fit simple BM and OU models of evolution to continuous trait data in R. 7.5 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit Brownian and OU models to log adult body mass for Primates (AdultBodyMass_g). Then answer the following questions. Which model fits best? What is the rate of evolution for the Brownian model? What is the strength of pull towards the long-term mean in the OU model? What does this value suggest? References "],["macroevolutionary-models-for-discrete-traits.html", "Chapter 8 Macroevolutionary models for discrete traits 8.1 Before you start 8.2 Preparation 8.3 Models of evolution for discrete traits 8.4 Ancestral state estimations 8.5 Summary 8.6 Practical exercises", " Chapter 8 Macroevolutionary models for discrete traits The aims of this exercise are to learn how to use R to fit macroevolutionary models in R to discrete traits. We will be using the evolution of head shape in natricine snakes as an example. The data and modified tree come from DEEPAK [CITE PAPER], and the tree comes from DEEPAK [CITE PAPER]. I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out DEEPAK [CITE PAPER]! 8.1 Before you start Open the 08-ModelsDiscrete.RProj file in the 08-ModelsDiscrete folder to open your R Project for this exercise. Make yourself a new R script for your code. You will also need to install the following packages: ape geiger treeplyr phytools 8.2 Preparation To begin we need to load the packages for this practical. # Load the packages library(ape) library(geiger) library(treeplyr) library(phytools) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. It is important to do these things before beginning a phylogenetic comparative analysis, so let’s run through that code again here. # Read in the data snakedata &lt;- read_csv(&quot;data/snake-heads.csv&quot;) # Check everything loaded corrected glimpse(snakedata) ## Rows: 206 ## Columns: 9 ## $ Species &lt;chr&gt; &quot;Adelophis_foxi&quot;, &quot;Afronatrix_anoscopus_2&quot;, &quot;Am… ## $ Ecomorph &lt;chr&gt; &quot;Burrowing&quot;, &quot;Aquatic&quot;, &quot;Terrestrial&quot;, &quot;Terrest… ## $ Diet &lt;chr&gt; &quot;annelids&quot;, &quot;aquatic generalist&quot;, &quot;anurans&quot;, &quot;a… ## $ ReproductiveMode &lt;chr&gt; &quot;Viviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Ovipar… ## $ HeadLength &lt;dbl&gt; 12.560, 25.100, 15.060, 20.105, 19.950, 18.810,… ## $ HeadWidth &lt;dbl&gt; 6.60, 15.80, 7.82, 9.13, 10.32, 9.82, 8.39, 11.… ## $ HeadHeight &lt;dbl&gt; 5.43, 10.30, 5.40, 6.61, 7.56, 5.80, 6.40, 8.70… ## $ EyeDistance &lt;dbl&gt; 4.01, 7.40, 4.85, 5.85, 5.84, 5.42, 6.00, 6.05,… ## $ TotalLength &lt;dbl&gt; 105, 194, 106, 185, 165, 155, NA, 163, 130, 309… To load the tree we will use read.nexus. # Read in the tree snaketree &lt;- read.nexus(&quot;data/snake-tree.nex&quot;) # Check it loaded correctly str(snaketree) ## List of 4 ## $ edge : int [1:496, 1:2] 250 251 252 253 254 255 256 257 258 259 ... ## $ edge.length: num [1:496] 4.695 2.225 0.587 0.307 0.832 ... ## $ Nnode : int 248 ## $ tip.label : chr [1:249] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_1&quot; &quot;Rhabdophis_nuchalis_2&quot; &quot;Rhabdophis_adleri_1&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary.tree(snaketree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(snaketree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(snaketree) ## [1] TRUE Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further. I haven’t printed check here as we already did this in the previous exercise and it’s a long list but we have already checked these in advance. Do not skip this step for your own analyses! # Check whether the names match in the data and the tree check &lt;- name.check(phy = snaketree, data = snakedata, data.names = snakedata$Species) # check Next we combine the tree and data to exclude species that are not in both, using the treeplyr function make.treedata. # Combine and match the tree and data snakestuff &lt;- make.treedata(tree = snaketree, data = snakedata, name_column = &quot;Species&quot;) # Look at the tree snakestuff$phy ## ## Phylogenetic tree with 162 tips and 161 internal nodes. ## ## Tip labels: ## Rhabdophis_leonardi, Rhabdophis_nuchalis_3, Rhabdophis_swinhonis_1, Rhabdophis_nigrocinctus, Rhabdophis_tigrinus, Rhabdophis_tigrinus_lateralis, ... ## ## Rooted; includes branch lengths. # Look at the data glimpse(snakestuff$dat) ## Rows: 162 ## Columns: 8 ## $ Ecomorph &lt;fct&gt; Semiaquatic, Terrestrial, Semiaquatic, Terrestr… ## $ Diet &lt;fct&gt; unknown, generalist, anurans, generalist, gener… ## $ ReproductiveMode &lt;fct&gt; Oviparous, Oviparous, Oviparous, Oviparous, Ovi… ## $ HeadLength &lt;dbl&gt; 25.640, 14.590, 18.030, 26.685, 23.760, 34.135,… ## $ HeadWidth &lt;dbl&gt; 13.72, 7.42, 8.58, 14.62, 13.94, 19.33, 11.79, … ## $ HeadHeight &lt;dbl&gt; 10.81, 5.79, 6.68, 9.83, 8.88, 12.90, 8.46, 8.6… ## $ EyeDistance &lt;dbl&gt; 8.16, 5.17, 5.74, 9.50, 7.89, 10.39, 8.27, 8.43… ## $ TotalLength &lt;int&gt; 120, 79, 123, 262, 132, 199, 226, 224, NA, NA, … Overall we have 162 species in the data and the tree. Then we replace the removed species names column, and save the data as a data frame for later analyses. # Make a new column called tiplabel with the tip labels in it snakestuff$dat$tiplabel &lt;- snakestuff$phy$tip.label # Force mydata to be a data frame mydata &lt;- as.data.frame(snakestuff$dat) Finally we save the tree: # Save tree as mytree mytree &lt;- snakestuff$phy Now we’re ready to run our analyses! 8.3 Models of evolution for discrete traits For fitting simple models of evolution to discrete data we will use the fitDiscrete function in the R package geiger. fitDiscrete is a likelihood based method, so the output will give the maximum likelihood (ML) estimates of the parameters. As an example, let’s look at the evolution of ecomorphs in our snake data. Before we start let’s make sure we have an idea of what these data look like. # How many species are in each category of ecomorph? mydata %&gt;% group_by(Ecomorph) %&gt;% summarise(number = n()) ## # A tibble: 5 x 2 ## Ecomorph number ## &lt;fct&gt; &lt;int&gt; ## 1 Aquatic 43 ## 2 Aquatic Burrowing 11 ## 3 Burrowing 17 ## 4 Semiaquatic 54 ## 5 Terrestrial 37 We can also visualize these variables on our tree by plotting them with colours. We’ll then create a vector of five colours for the ecomorphs. These need to be in alphabetical order, so the colours should be in the order Aquatic, Aquatic burrower, Burrower, Semi-aquatic, Terrestrial. # Set up list of colours ecomorph.colors &lt;- c(&quot;darkblue&quot;, &quot;plum&quot;, &quot;chocolate&quot;, &quot;lightblue&quot;, &quot;lightgreen&quot;) Finally we can plot the tree with coloured tip labels to match the ecomorphs. I’ve rearranged the colour order in the legend so it makes more sense biologically (i.e. putting the aquatic and Semi-aquatic next to each other rather than ordering it alphabetically). To make things a bit easier to see I’ve left off the tip labels. # Plot the tree with colours at the tips to represent ecomorph plot(mytree, cex = 0.5, adj = c(0.2), type = &quot;fan&quot;, no.margin = TRUE, show.tip.label = FALSE) tiplabels(pch = 16, col = ecomorph.colors[mydata$Ecomorph]) legend(&quot;bottomleft&quot;, pch = 15, bty = &quot;n&quot;, legend = c(&quot;Aquatic&quot;, &quot;Semi-aquatic&quot;, &quot;Aquatic burrower&quot;, &quot;Burrower&quot;, &quot;Terrestrial&quot;), col = c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;plum&quot;, &quot;chocolate&quot;, &quot;lightgreen&quot;)) Some ecomorphs are clustered, but others appear across the phylogeny (this is the result of some pretty cool convergent evolution - check out DEEPAK CITE PAPER for more details). 8.3.1 Fitting the ER, SYM and ARD models of evolution using fitDiscrete We’ll fit three commonly used evolutionary models to the data; the equal rates (ER) model, the symmetric rates (SYM) model and the all rates different (ARD) model. As a quick reminder, in the ER model, transitions between any pair of states occur at the same rate and are therefore equally probable. This is also known as the Mk1 model because it as a Markov model (Mk) with only 1 parameter (k). In the SYM model transitions between any pair of states occurs at the same rate regardless of direction, but that the rate of change differs among states. A symmetric model with only 2 states becomes an equal rates (Mk1) model. Finally, in the ARD model all transitions between pairs of states occurs at different rates. It’s important to be wary of over-fitting with this model as it can result in a lot of rates when you have more than a few states. For more details on these models please see the Primer. We are going to use the package geiger to fit models in this exercise, so we need the additional preparation step we first met in chapter 05-PhyloSignal. We need to create an object in R that only contains the variable required, and the species names (so we can match it up to the tree). We use the function pull to extract just the ecomorph values. We then name these values with the species names from mydata using the function names. Note that this requires the trait data is in the same order as the tree tip labels, but luckily make.treedata does this automatically. # Create ecomorph containing just ecomorph values ecomorph &lt;- pull(mydata, Ecomorph) # Make sure ecomorph is a character, not a factor ecomorph &lt;- as.character(ecomorph) # Look at the first few rows head(ecomorph) ## [1] &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Terrestrial&quot; ## [6] &quot;Terrestrial&quot; # Give log head length names = species names at the tips of the phylogeny names(ecomorph) &lt;- mydata$tiplabel # Look at the first few rows head(ecomorph) ## Rhabdophis_leonardi Rhabdophis_nuchalis_3 ## &quot;Semiaquatic&quot; &quot;Terrestrial&quot; ## Rhabdophis_swinhonis_1 Rhabdophis_nigrocinctus ## &quot;Semiaquatic&quot; &quot;Terrestrial&quot; ## Rhabdophis_tigrinus Rhabdophis_tigrinus_lateralis ## &quot;Terrestrial&quot; &quot;Terrestrial&quot; Now we have a list of values with associated species names. To fit the ER model we can then use the code below. # Fit the ER model equal &lt;- fitDiscrete(mytree, ecomorph, model = &quot;ER&quot;) Let’s look at the output for the equal rates model: # Look at the output equal ## GEIGER-fitted comparative model of discrete data ## fitted Q matrix: ## Aquatic Aquatic Burrowing Burrowing ## Aquatic -0.034973712 0.008743428 0.008743428 ## Aquatic Burrowing 0.008743428 -0.034973712 0.008743428 ## Burrowing 0.008743428 0.008743428 -0.034973712 ## Semiaquatic 0.008743428 0.008743428 0.008743428 ## Terrestrial 0.008743428 0.008743428 0.008743428 ## Semiaquatic Terrestrial ## Aquatic 0.008743428 0.008743428 ## Aquatic Burrowing 0.008743428 0.008743428 ## Burrowing 0.008743428 0.008743428 ## Semiaquatic -0.034973712 0.008743428 ## Terrestrial 0.008743428 -0.034973712 ## ## model summary: ## log-likelihood = -176.839091 ## AIC = 355.678181 ## AICc = 355.703181 ## free parameters = 1 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 100 ## frequency of best fit = 1.00 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates This looks very similar to the output from fitContinuous in the 08-ModelsContinuous exercise. We’ve got a model summary, with log likelihoods and AIC scores, convergence diagnostics and an object summary. The only major difference is the first part, which gives us a fitted transition matrix or \\(Q\\) matrix, rather than a summary of model parameters. In fact the \\(Q\\) matrix is the model parameters for these models as it contains all the rates of change between different states. This is an equal rates model, so the off-diagonal elements are all same and show that the rate of change from one state to any other state is 0.00874. Why are the diagonal elements of the \\(Q\\) matrix -0.034973712? The rows of the \\(Q\\) matrix must sum to zero: -0.034973712 + (4 * 0.008743428) = 0. To fit the SYM model we just switch the model name. Note that this might be a bit slow on your computer as we have quite a lot of different ecomorphs, so a lot of different rates to fit. A good point to grab a coffee/tea/biscuit! # Fit the SYM model sym &lt;- fitDiscrete(mytree, ecomorph, model = &quot;SYM&quot;) # Look at the output sym ## GEIGER-fitted comparative model of discrete data ## fitted Q matrix: ## Aquatic Aquatic Burrowing Burrowing ## Aquatic -3.410177e-02 6.787716e-03 8.536122e-03 ## Aquatic Burrowing 6.787716e-03 -6.787716e-03 1.298292e-35 ## Burrowing 8.536122e-03 1.298292e-35 -1.172385e-02 ## Semiaquatic 1.877793e-02 7.561620e-31 3.187730e-03 ## Terrestrial 2.213499e-23 6.245556e-20 9.633946e-20 ## Semiaquatic Terrestrial ## Aquatic 1.877793e-02 2.213499e-23 ## Aquatic Burrowing 7.561620e-31 6.245556e-20 ## Burrowing 3.187730e-03 9.633946e-20 ## Semiaquatic -6.519591e-02 4.323024e-02 ## Terrestrial 4.323024e-02 -4.323024e-02 ## ## model summary: ## log-likelihood = -148.281974 ## AIC = 316.563949 ## AICc = 318.020902 ## free parameters = 10 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 2 ## frequency of best fit = 0.02 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates Again the \\(Q\\) matrix is the key output here. You could just read the numbers, we can see this more clearly if we plot the \\(Q\\) matrix for the model: # Plot Q matrix as network plot.gfit(sym) The transition rate between Semi-aquatic and Terrestrial is highest (0.043), followed by transitions between Semi-aquatic and Aquatic (0.019). Burrowing and Aquatic (0.009) and Aquatic Burrowing and Aquatic (0.007) have the next highest rates, followed by Burrowing and Semi-aquatic (0.003). All the other rates are &lt; 0.001 so they appear as zeros on this plot Finally let’s fit the ARD model. Again this may take some time! Go and grab a tea/coffee/biscuit or take a short break. # Fit the ARD model ard &lt;- fitDiscrete(mytree, ecomorph, model = &quot;ARD&quot;) # Look at the output ard ## GEIGER-fitted comparative model of discrete data ## fitted Q matrix: ## Aquatic Aquatic Burrowing Burrowing ## Aquatic -3.871095e-02 7.710925e-03 1.070720e-02 ## Aquatic Burrowing 2.966658e-08 -2.968995e-08 6.508677e-12 ## Burrowing 1.256202e-11 1.899379e-11 -2.336514e-08 ## Semiaquatic 1.592947e-02 1.268934e-11 2.496574e-03 ## Terrestrial 1.404585e-09 1.052951e-10 2.519973e-12 ## Semiaquatic Terrestrial ## Aquatic 2.029283e-02 9.013088e-14 ## Aquatic Burrowing 8.331062e-12 8.532529e-12 ## Burrowing 2.332776e-08 5.825714e-12 ## Semiaquatic -5.538251e-02 3.695646e-02 ## Terrestrial 2.678831e-03 -2.678832e-03 ## ## model summary: ## log-likelihood = -145.506019 ## AIC = 331.012038 ## AICc = 336.969484 ## free parameters = 20 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 1 ## frequency of best fit = 0.01 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates Again the \\(Q\\) matrix is the key output. We can plot the \\(Q\\) matrix for the model: # Plot Q matrix as network plot.gfit(ard) This is quite complex because in the ARD model we have different rates for each type of state change. Here, for example, the bottom left hand arrows joining Semi-aquatic and Terrestrial show that rates of change from Semi-aquatic to Terrestrial (0.037) are higher than those from Terrestrial to Semi-aquatic (0.003). These plots can be a little easier to read if we hide all the transitions where rates are &lt; 0.001 as follows. # Plot Q matrix as network without zeros plot.gfit(ard, show.zeros = FALSE) For now these plots are pretty simple, but you can add some code to make the arrows different sizes etc. if you need to using the code here http://blog.phytools.org/2020/09/graphing-fitted-m-k-model-with.html. Also check out future versions of phytools which should have these functions added. 8.3.2 Comparing models of evolution using AIC As we discussed in the continuous traits exercise in 08-ModelsContinuous, we often want to know which of the models fits our variable best. We can use fitDiscrete to fit the models we are interested in and then compare them using AIC. We can extract the AICs from the models we fitted above as follows: equal$opt$aic ## [1] 355.6782 sym$opt$aic ## [1] 316.5639 ard$opt$aic ## [1] 331.012 The “best” model is the one with the smallest AIC. Here the best model of evolution appears to be the SYM model, whereby rates of transition are the same in both directions, but are different for the different pairs of ecomorphs. Alternatively we can use \\(\\Delta\\)AIC or AIC weights to compare our models using the following code and the geiger function aicw: aic.scores &lt;- setNames(c(equal$opt$aic, sym$opt$aic, ard$opt$aic), c(&quot;equal&quot;, &quot;symmetric&quot;, &quot;different&quot;)) aicw(aic.scores) ## fit delta w ## equal 355.6782 39.11423 3.207273e-09 ## symmetric 316.5639 0.00000 9.992717e-01 ## different 331.0120 14.44809 7.283178e-04 aicw outputs the AIC (fit), \\(\\Delta\\)AIC (delta) and AIC weights (w) for each of the models we fitted. The best model is the model with \\(\\Delta\\)AIC = 0 or with AICw closest to 1. Using \\(\\Delta\\)AIC we can conclude that the SYM model is the best fit to the data. 8.4 Ancestral state estimations I’m not a big fan of ancestral state estimation as you probably realised from the Primer! There are many reasons to be highly sceptical of ancestral state estimates and interpretations of macroevolutionary patterns and process that are based on them. However, if you want to know if evolutionary tempo or mode have varied over clade history based on the state of a discrete trait as we intend to do in the next chapter, you’ll need to do it so you can assign each node to a particular state. We’ll use ape’s ace function here. There are other options out there, for example in the phytools package, but ace will work for our purposes. To perform ancestral state estimation of ecomorphs for snakes we can use the ecomorph object we made earlier and used to fit the ER, SYM and ARD models. Recall that ecomorph is just the Ecomorph column from the snake heads dataset, in the same order as the tips in the tree, with names equal to the tip labels/Species names in the tree. # Take a quick look at the first few rows of ecomorph head(ecomorph) ## Rhabdophis_leonardi Rhabdophis_nuchalis_3 ## &quot;Semiaquatic&quot; &quot;Terrestrial&quot; ## Rhabdophis_swinhonis_1 Rhabdophis_nigrocinctus ## &quot;Semiaquatic&quot; &quot;Terrestrial&quot; ## Rhabdophis_tigrinus Rhabdophis_tigrinus_lateralis ## &quot;Terrestrial&quot; &quot;Terrestrial&quot; To perform an ancestral state estimation of ecomorphs under the symmetric model (the best fitting model for the data as discovered above) we use this code: # Ancestral state estimation of ecomorph under the SYM model ancestral_ecomorphs &lt;- ace(ecomorph, mytree, type = &quot;discrete&quot;, model = &quot;SYM&quot;) ## Warning in log(comp[-TIPS]): NaNs produced ## Warning in sqrt(diag(solve(h))): NaNs produced You should notice a series of warning messages appear that say NaNs produced and NA/Inf replaced by maximum positive value. Don’t worry about this – it happens when rates for one transition are particularly low (and we know from above that many of the transition rates were &lt; 0.001) but doesn’t really affect our node state estimates. ace now defaults to a joint estimation procedure, where the ancestral states are optimized based on all information in the tree, not just the states at descendant tips. Older versions of ace did not do this, so be wary of this when reading older critiques of this method We can look at the first few rows of our ancestral state estimates by typing: head(ancestral_ecomorphs$lik.anc) In this matrix the rows correspond to nodes in the tree (although the numbering is bit off; we don’t need to worry about this here but it will come up in the next exercise) and the five columns give the scaled likelihoods that the node is in each of the different ecomorphs. The scaled likelihoods are like probabilities, so for the first node, the probability of it being Aquatic is highest (probability = 0.5417), followed by the probability of it being Semi-aquatic (0.3587), Terrestrial (0.0755), Burrowing (0.0206), or Aquatic Burrowing (0.0035). These scaled likelihoods can be visualized with pie charts on the tree we plotted earlier byt adding the nodelabels line of code below. # Plot the tree with colours at the tips and nodes to represent ecomorph plot(mytree, cex = 0.5, adj = c(0.2), type = &quot;fan&quot;, no.margin = TRUE, show.tip.label = FALSE) tiplabels(pch = 16, col = ecomorph.colors[mydata$Ecomorph]) nodelabels(pie = ancestral_ecomorphs$lik.anc, piecol = ecomorph.colors, cex = 0.5) legend(&quot;bottomleft&quot;, pch = 15, bty = &quot;n&quot;, legend = c(&quot;Aquatic&quot;, &quot;Semi-aquatic&quot;, &quot;Aquatic burrower&quot;, &quot;Burrower&quot;, &quot;Terrestrial&quot;), col = c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;plum&quot;, &quot;chocolate&quot;, &quot;lightgreen&quot;)) Aquatic is most commonly estimated as the ancestral ecomorph for natricine snakes, with Semi-aquatic as a close second, and with multiple transitions to other ecomorphs throughout the tree. Ancestral state estimates (not reconstructions) are, at best, weighted averages of your trait based on branch lengths of the phylogeny and the model of evolution used. If your phylogeny or traits or model have error (and they always will) then your ancestral state estimates should be interpreted with care. 8.5 Summary You should now know how to fit simple models of evolution to discrete trait data in R. 8.6 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit equal rates, symmetric rates and all rates different models to the social status variable for Primates (SocialStatus). Note that social status has two states: non-social (1) or social (2). Then answer the following questions. Which model fits best? What is the transition rate from non-social (1) to social (2), and vice versa, in the all rates different model? What does this mean biologically? Plot ancestral state estimates of social status (from the ARD model) on the phylogeny. Is the root node estimated as being non-social or social? Why didn’t I ask you to fit the symmetric model? References "],["beyond-simple-macroevolutionary-models-of-trait-evolution.html", "Chapter 9 Beyond simple macroevolutionary models of trait evolution 9.1 Before you start 9.2 Preparation 9.3 More complex models of trait evolution 9.4 Summary 9.5 Practical exercises", " Chapter 9 Beyond simple macroevolutionary models of trait evolution The aims of this exercise are to learn how to use R to fit slightly more complex macroevolutionary models. Our question here still revolves around the snake head shape data. In 08-ModelsContinuous we fitted simple Brownian Motion (BM) and Ornstein-Uhlenbeck (OU) models to the head length data. We found that the OU model was a better fit, but we didn’t account for any of the limitations of the BM or OU models (see Primer). In the both models we only allowed head length to have one rate of evolution across the tree, and in the OU model we only fit a single optimum. We can extend these models by relaxing these assumptions. In 09-ModelsDiscrete we fitted three simple models of evolution to discrete data to see how ecomorph changed across the tree. We found the best fitting model was the symmetric (SYM) model, where rates of transition between ecomorphs were the same in both directions, but were different for the different pairs of ecomorphs. A more interesting question is how do these different ecomorphs relate to the head shape data? Do aquatic species have wider heads than terrestrial species? Are burrowers evolving their head shape more quickly than semi-aquatic species? We can use more complex evolutionary models to approach these questions. We will be using the evolution of head shape in natricine snakes as an example. The data and modified tree come from DEEPAK [CITE PAPER], and the tree comes from DEEPAK [CITE PAPER]. I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out DEEPAK [CITE PAPER]! 9.1 Before you start Open the 09-ModelsBeyond.RProj file in the 09-ModelsBeyond folder to open your R Project for this exercise. Make yourself a new R script for your code. You will also need to install the following packages: ape geiger treeplyr OUwie phytools 9.2 Preparation To begin we need to load the packages for this practical. # Load the packages library(ape) library(geiger) library(treeplyr) library(phytools) library(OUwie) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. It is important to do these things before beginning a phylogenetic comparative analysis, so let’s run through that code again here. # Read in the data snakedata &lt;- read_csv(&quot;data/snake-heads.csv&quot;) # Check everything loaded corrected glimpse(snakedata) ## Rows: 206 ## Columns: 9 ## $ Species &lt;chr&gt; &quot;Adelophis_foxi&quot;, &quot;Afronatrix_anoscopus_2&quot;, &quot;Am… ## $ Ecomorph &lt;chr&gt; &quot;Burrowing&quot;, &quot;Aquatic&quot;, &quot;Terrestrial&quot;, &quot;Terrest… ## $ Diet &lt;chr&gt; &quot;annelids&quot;, &quot;aquatic generalist&quot;, &quot;anurans&quot;, &quot;a… ## $ ReproductiveMode &lt;chr&gt; &quot;Viviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Ovipar… ## $ HeadLength &lt;dbl&gt; 12.560, 25.100, 15.060, 20.105, 19.950, 18.810,… ## $ HeadWidth &lt;dbl&gt; 6.60, 15.80, 7.82, 9.13, 10.32, 9.82, 8.39, 11.… ## $ HeadHeight &lt;dbl&gt; 5.43, 10.30, 5.40, 6.61, 7.56, 5.80, 6.40, 8.70… ## $ EyeDistance &lt;dbl&gt; 4.01, 7.40, 4.85, 5.85, 5.84, 5.42, 6.00, 6.05,… ## $ TotalLength &lt;dbl&gt; 105, 194, 106, 185, 165, 155, NA, 163, 130, 309… To load the tree we will use read.nexus. # Read in the tree snaketree &lt;- read.nexus(&quot;data/snake-tree.nex&quot;) # Check it loaded correctly str(snaketree) ## List of 4 ## $ edge : int [1:496, 1:2] 250 251 252 253 254 255 256 257 258 259 ... ## $ edge.length: num [1:496] 4.695 2.225 0.587 0.307 0.832 ... ## $ Nnode : int 248 ## $ tip.label : chr [1:249] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_1&quot; &quot;Rhabdophis_nuchalis_2&quot; &quot;Rhabdophis_adleri_1&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary.tree(snaketree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(snaketree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(snaketree) ## [1] TRUE Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further.I haven’t printed check here as we already did this in 08-ModelsContinuous and it’s a long list but we have already checked these in advance. Do not skip this step for your own analyses! # Check whether the names match in the data and the tree check &lt;- name.check(phy = snaketree, data = snakedata, data.names = snakedata$Species) # Look at check # check Next we combine the tree and data to exclude species that are not in both, using the treeplyr function make.treedata. # Combine and match the tree and data snakestuff &lt;- make.treedata(tree = snaketree, data = snakedata, name_column = &quot;Species&quot;) # Look at the tree snakestuff$phy ## ## Phylogenetic tree with 162 tips and 161 internal nodes. ## ## Tip labels: ## Rhabdophis_leonardi, Rhabdophis_nuchalis_3, Rhabdophis_swinhonis_1, Rhabdophis_nigrocinctus, Rhabdophis_tigrinus, Rhabdophis_tigrinus_lateralis, ... ## ## Rooted; includes branch lengths. # Look at the data glimpse(snakestuff$dat) ## Rows: 162 ## Columns: 8 ## $ Ecomorph &lt;fct&gt; Semiaquatic, Terrestrial, Semiaquatic, Terrestr… ## $ Diet &lt;fct&gt; unknown, generalist, anurans, generalist, gener… ## $ ReproductiveMode &lt;fct&gt; Oviparous, Oviparous, Oviparous, Oviparous, Ovi… ## $ HeadLength &lt;dbl&gt; 25.640, 14.590, 18.030, 26.685, 23.760, 34.135,… ## $ HeadWidth &lt;dbl&gt; 13.72, 7.42, 8.58, 14.62, 13.94, 19.33, 11.79, … ## $ HeadHeight &lt;dbl&gt; 10.81, 5.79, 6.68, 9.83, 8.88, 12.90, 8.46, 8.6… ## $ EyeDistance &lt;dbl&gt; 8.16, 5.17, 5.74, 9.50, 7.89, 10.39, 8.27, 8.43… ## $ TotalLength &lt;int&gt; 120, 79, 123, 262, 132, 199, 226, 224, NA, NA, … Overall we have 162 species in the data and the tree. Then we replace the removed species names column, and save the data as a data frame for later analyses. # Make a new column called tiplabel with the tip labels in it snakestuff$dat$tiplabel &lt;- snakestuff$phy$tip.label # Force mydata to be a data frame mydata &lt;- as.data.frame(snakestuff$dat) Finally we save the tree: # Save tree as mytree mytree &lt;- snakestuff$phy Now we’re ready to run our analyses! 9.3 More complex models of trait evolution We are now going to fit some of the slightly more complicated models of trait evolution that we discussed in the Primer. We will fit these using the package OUwie. There’s a little bit of extra preparation required to fit these models which we will do first. 9.3.1 Preparing the tree and data for OUwie To use OUwie we need to do a couple of things. We need to estimate the node values for each evolutionary regime in the analysis (see below), and we have to set up a dataframe in a particular way. Let’s sort out our node values first. 9.3.1.1 Estimating node values for the tree In 09-ModelsDiscrete we fitted three simple models of evolution to discrete data to see how ecomorph changed across the tree. We found the best fitting model was the symmetric (SYM) model, where rates of transition between ecomorphs were the same in both directions, but were different for the different pairs of ecomorphs. To extend this we can test whether head shape evolution varies among snakes with different ecomorphs. We refer to the different ecomorphs as representing different evolutionary regimes. To fit these more complex models using OUwie we need to assign each node in the tree to one of the ecomorph categories. This is of course a massive assumption, but we need it to determine which branches should belong to which evolutionary regimes. First we need to determine which model of evolution best fits the ecomorph data. We can do this using fitDiscrete in geiger. In fact this is exactly what we did in 09-ModelsDiscrete, so I’ll just quickly recap this here: To get the data into the correct format, we use the function pull to extract just the ecomorph values. We then name these values with the species names from mydata using the function names. Note that this requires the trait data is in the same order as the tree tip labels, but luckily make.treedata does this automatically. # Create ecomorph containing just ecomorph values ecomorph &lt;- pull(mydata, Ecomorph) # Make sure ecomorph is a character, not a factor ecomorph &lt;- as.character(ecomorph) # Look at the first few rows head(ecomorph) ## [1] &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Terrestrial&quot; ## [6] &quot;Terrestrial&quot; # Give log head length names = species names at the tips of the phylogeny names(ecomorph) &lt;- mydata$tiplabel # Look at the first few rows head(ecomorph) ## Rhabdophis_leonardi Rhabdophis_nuchalis_3 ## &quot;Semiaquatic&quot; &quot;Terrestrial&quot; ## Rhabdophis_swinhonis_1 Rhabdophis_nigrocinctus ## &quot;Semiaquatic&quot; &quot;Terrestrial&quot; ## Rhabdophis_tigrinus Rhabdophis_tigrinus_lateralis ## &quot;Terrestrial&quot; &quot;Terrestrial&quot; To fit the ER, SYM and ARD models we can then use the code below. I’ve commented these out here on the assumption that you’ve already run this in 09-ModelsDiscrete. The SYM and ARD models take a while to run so don’t rerun thee unless you need to! # Fit the models # equal &lt;- fitDiscrete(mytree, ecomorph, model = &quot;ER&quot;) # sym &lt;- fitDiscrete(mytree, ecomorph, model = &quot;SYM&quot;) # ard &lt;- fitDiscrete(mytree, ecomorph, model = &quot;ARD&quot;) We can then use AIC to determine the “best model” from these three: # Extract AICc values for each model and give them names aic.discrete &lt;- setNames(c(equal$opt$aic, sym$opt$aic, ard$opt$aic), c(&quot;equal&quot;, &quot;symmetric&quot;, &quot;different&quot;)) # Compare AICw values aicw(aic.discrete) ## fit delta w ## equal 355.6782 39.11423 3.207273e-09 ## symmetric 316.5639 0.00000 9.992717e-01 ## different 331.0120 14.44809 7.283178e-04 The best model of evolution is the symmetric model, the same as we found in 09-ModelsDiscrete. Phew! Next we use this model to determine what the best fit state value is for each node. Let’s remind ourselves of the ancestral state estimates we got for ecomorphs in 09-ModelsDiscrete… # Ancestral state estimation of ecomorph under the SYM model ancestral_ecomorphs &lt;- ace(ecomorph, mytree, type = &quot;discrete&quot;, model = &quot;SYM&quot;) ## Warning in log(comp[-TIPS]): NaNs produced ## Warning in sqrt(diag(solve(h))): NaNs produced You should notice a series of warning messages appear that say NaNs produced and NA/Inf replaced by maximum positive value. These can be ignored (see 09-ModelsDiscrete). # Plot the tree with colours at the tips and nodes to represent ecomorph plot(mytree, cex = 0.5, adj = c(0.2), type = &quot;fan&quot;, no.margin = TRUE, show.tip.label = FALSE) tiplabels(pch = 16, col = ecomorph.colors[mydata$Ecomorph]) nodelabels(pie = ancestral_ecomorphs$lik.anc, piecol = ecomorph.colors, cex = 0.5) legend(&quot;bottomleft&quot;, pch = 15, bty = &quot;n&quot;, legend = c(&quot;Aquatic&quot;, &quot;Semi-aquatic&quot;, &quot;Aquatic burrower&quot;, &quot;Burrower&quot;, &quot;Terrestrial&quot;), col = c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;plum&quot;, &quot;chocolate&quot;, &quot;lightgreen&quot;)) Each pie shows the scaled likelihoods of the node being within each of the five ecomorphs. Many of these are ambiguous, so how do we pick the “best” state? To solve this problem we use simulations. We use the transition or \\(Q\\) matrix from the SYM model and use it to simulate tip values and node values of ecomorph category for the tree. We repeat this a number of times - below I use 500 simulations but if the states are fairly simply distributed across the tree you could use fewer. This takes a bit of time to run… # Simulate node and tip values for 500 trees using the SYM model trees.SYM &lt;- make.simmap(mytree, ecomorph, model = &quot;SYM&quot;, nsim = 500) ## make.simmap is sampling character histories conditioned on ## the transition matrix ## ## Q = ## Aquatic Aquatic Burrowing Burrowing Semiaquatic ## Aquatic -0.033980020 0.006989515 0.008443046 0.018547459 ## Aquatic Burrowing 0.006989515 -0.006989515 0.000000000 0.000000000 ## Burrowing 0.008443046 0.000000000 -0.011914946 0.003471901 ## Semiaquatic 0.018547459 0.000000000 0.003471901 -0.065115565 ## Terrestrial 0.000000000 0.000000000 0.000000000 0.043096205 ## Terrestrial ## Aquatic 0.0000000 ## Aquatic Burrowing 0.0000000 ## Burrowing 0.0000000 ## Semiaquatic 0.0430962 ## Terrestrial -0.0430962 ## (estimated using likelihood); ## and (mean) root node prior probabilities ## pi = ## Aquatic Aquatic Burrowing Burrowing Semiaquatic ## 0.2 0.2 0.2 0.2 ## Terrestrial ## 0.2 ## Done. # Store the results of the summary of the 500 trees summary.SYM &lt;- summary(trees.SYM) Now we can use a simple trick to extract the most likely states. We use apply to extract the maximum value for each node from the summary.SYM. # Get the max likelihood state at each node best &lt;- apply(summary.SYM$ace, 1, which.max) # Look at first few rows of the output head(best) ## 163 164 165 166 167 168 ## 1 1 4 4 4 4 Finally we assign these “best” node states to the tree node labels. Note that best only contains the numerical versions of the ecomorphs, i.e. 1, 2, 3 etc. rather than the ecomorph names, so we need to use levels(mydata$Ecomorph)[best] to select the names that go with the numbers. # Assign to the tree node labels mytree$node.label &lt;- levels(as.factor(mydata$Ecomorph))[best] 9.3.1.2 Preparing the data Finally for OUwie to work we need to set up a dataset with three columns: the species names first, then the evolutionary regime which in this case is the ecomorphs, and then the continuous variable we think might be evolving differently in response to different regimes. Here we are going to look at head width, as we predict that burrowing snakes and aquatic snakes may have narrower heads than terrestrial species. Note that I have also log transformed head width. # Make new dataset with just three columns for OUwie headw &lt;- data.frame(species = mydata$tiplabel, regime = mydata$Ecomorph, trait = log(mydata$HeadWidth)) # look at the first few rows head(headw) ## species regime trait ## 1 Rhabdophis_leonardi Semiaquatic 2.618855 ## 2 Rhabdophis_nuchalis_3 Terrestrial 2.004179 ## 3 Rhabdophis_swinhonis_1 Semiaquatic 2.149434 ## 4 Rhabdophis_nigrocinctus Terrestrial 2.682390 ## 5 Rhabdophis_tigrinus Terrestrial 2.634762 ## 6 Rhabdophis_tigrinus_lateralis Terrestrial 2.961658 We are now ready to run some more complex models with OUwie! This is a key point to remember the “Jurassic Park caveat”; just because we can fit all of these models to our data doesn’t mean that we should. Before applying any of the models below, think very carefully. What questions are you trying to answer? What would a result one way or the other tell you about evolution in your study group? It is often tempting to just fit all of these models, then tell a “just so” story about why one model fits best. But without a clear question and a prediction about what you might find, at best the results might not tell you anything interesting about evolution in your group, and at worst the results may be nonsensical. This is especially true when sample sizes are low, and/or we expect there is error in our data or our phylogeny. Pay close attention to the caveats discussed below. Especially for the complex models near the end of the exercise. 9.3.2 Running models using OUwie Before we dive into the exciting new models, it’s worth using OUwie to fit the simple BM and OU models we already learned how to fit in 08-ModelsContinuous first. Why? Well, it’s always a good idea to compare complex models to simpler models to see if adding complexity is worthwhile. Sometimes a BM model fits just as well as these more complex ones. We’ll fit the simple models and the more complex ones so we can compare them all using AIC at the end of the exercise. 9.3.3 Single rate BM models As a quick reminder, the BM model is a so called “random walk” model where traits change gradually through time. The model has two parameters, the Brownian rate parameter, \\(\\sigma^2\\) and the state of the root at time zero, \\(z(0)\\). To fit a BM model in OUwie we use the following code. The model name here is BM1 to indicate this is a simple BM model with only one rate of evolution. BM &lt;- OUwie(mytree, headw, model = &quot;BM1&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the ## determinant and inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. You should see some messages here. An algorithm was not specified. Defaulting to computing the determinant and inversion of the vcv. just tells you that the model will use the older (slower) method to fit the likelihood, rather than the faster three-point algorithm. The other messages just tell you the code is working, and when it is finished. This is for people running complex analyses that take some time, just so they know the code is running! Let’s look at the results. BM ## ## Fit ## lnL AIC AICc BIC model ntax ## -221.3888 446.7775 446.853 452.9527 BM1 162 ## ## Rates ## 1 ## alpha NA ## sigma.sq 0.08590249 ## ## Optima ## 1 ## estimate 2.1862946 ## se 0.7488931 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) and \\(\\alpha\\). We don’t fit \\(\\alpha\\) in a BM model so it’s NA in this output. The Optima section tells us what the trait “optima” are for each regime. In a BM model we don’t have any different regimes so this is just estimated value of log head width at the root, \\(z(0)\\). Arrived at a reliable solution tells us that the model converged on a reliable set of parameter estimates. The rest of the output includes log likelihood and AIC of the model etc. 9.3.4 Single optimum OU models Again as a reminder, the OU model is a random walk where trait values are pulled back towards some “optimal” value with an attraction strength proportional to the “rubber-band” parameter \\(\\alpha\\). The OU model has four parameters the Brownian rate parameter, \\(\\sigma^2\\), the state of the root at time zero, \\(z(0)\\), the long-term mean, \\(\\mu\\), and the strength of evolutionary force that returns traits back towards the long-term mean if they evolve away from it, \\(\\alpha\\). If \\(\\alpha\\) is close to zero then evolution is approximately Brownian. To fit a single peak OU model in OUwie we use the following code. The model name here is OU1 to indicate this is a simple OU model with only one rate of evolution and one peak. OU &lt;- OUwie(mytree, headw, model = &quot;OU1&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the ## determinant and inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Let’s look at the results. OU ## ## Fit ## lnL AIC AICc BIC model ntax ## -80.87437 167.7487 167.9006 177.0115 OU1 162 ## ## ## Rates ## alpha sigma.sq ## 9.094923 2.927039 ## ## Optima ## 1 ## estimate 2.30982153 ## se 0.03169213 ## ## ## Half life (another way of reporting alpha) ## alpha ## 0.07621254 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) and \\(\\alpha\\). The Optima section tells us what the trait “optima” are for each regime. In a one peak OU model we only have one optimum, so here there is only one estimate for the overall long-term mean for log head width. Finally, the OU model output also reports the Half life of \\(\\alpha\\). This is how long it takes for the trait to get half way to its long-term mean. Here the half life is 0.07621254, i.e. it takes 0.07621254 units of branch length for log head width to get half way to the optima of head width. That’s pretty fast! 9.3.5 Multi-rate BM (BMS) models Now we’ve fitted the simple models, let’s make things more complex and, hopefully, more realistic. The first model we will fit is a BM model where different rates of evolution are allowed for each evolutionary regime. Here the evolutionary regimes are the ecomorphs. BMS models allow different \\(\\sigma^2\\) values for different regimes. We can use the code below to fit them. # Fit BMS model BMS &lt;- OUwie(mytree, headw, model = &quot;BMS&quot;, root.station = FALSE) ## Warning: An algorithm was not specified. Defaulting to computing the ## determinant and inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Note that we set the root to invoke the non-censored model of O’Meara et al. (2006), by using root.station = FALSE. This means a single regime at the root is estimated. If we instead want to use the censored model of O’Meara et al. (2006) or the group means model of Thomas, Freckleton, and Székely (2006), where the number of means equals the number of regimes, we use root.station == TRUE. However, the beaviour of these latter two models appears to approximate OUMV (see below) and is not fully understood, so the authors of OUwie recommend using root.station = FALSE whenever you fit a BMS model. Let’s look at the results. BMS ## ## Fit ## lnL AIC AICc BIC model ntax ## -157.5303 327.0606 327.6025 345.5862 BMS 162 ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha NA NA NA NA NA ## sigma.sq 0.02204637 0.003111568 0.01164359 0.1598795 0.004688046 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 1.9969746 1.9969746 1.9969746 1.9969746 1.9969746 ## se 0.4476263 0.4476263 0.4476263 0.4476263 0.4476263 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) for each of the ecomorphs or evolutionary regimes. The semi-aquatic ecomorphs have a much higher rate of evolution than the others. Again as this is a BM model it does not have \\(\\alpha\\) estimates. The Optima section tells us what root state \\(z0\\) is for each ecomorph. In the BMS model this is the same for each evolutionary regime. 9.3.6 Multi-optima OU (OUM) models Next let’s fit an OUM model. These models allow different trait optima or long-term mean values for different evolutionary regimes but the same \\(\\sigma^2\\) and \\(\\alpha\\). Here the evolutionary regimes are the ecomorphs. We fit the model as follows: # Fit OUM model OUM &lt;- OUwie(mytree, headw, model = &quot;OUM&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the ## determinant and inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Let’s look at the results. OUM ## ## Fit ## lnL AIC AICc BIC model ntax ## -35.86695 85.73389 86.46117 107.3471 OUM 162 ## ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha 9.094924 9.094924 9.094924 9.094924 9.094924 ## sigma.sq 1.679142 1.679142 1.679142 1.679142 1.679142 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 2.55900183 2.07636983 1.63753812 2.36487673 2.32107617 ## se 0.04635845 0.09160788 0.07368935 0.04202907 0.04994948 ## ## ## Half life (another way of reporting alpha) ## Aquatic Aquatic Burrowing Burrowing Semiaquatic ## 0.07621253 0.07621253 0.07621253 0.07621253 ## Terrestrial ## 0.07621253 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) and \\(\\alpha\\). In an OUM model these are the same for each regime/ecomorph, so the Half life of \\(\\alpha\\) is also the same for each regime. The key part in this output is the Optima section as the OUM model fits a trait “optimum” or long-term mean for each regime. So here we have an estimate for the long-term mean for log head width for each ecomorph. Note that the value for Burrowing species is quite a lot lower than for the other ecomorphs, perhaps reflecting evolution towards narrower heads in that ecomorph? It’s important to stop and think carefully before interpreting these “optima” or long-term means. Do they make sense in terms of what we know about head shape in these snake ecomorphs? I think it looks pretty sensible given where they plot (see DEEPAK) but it’s always good to check there’s nothing weird going on. 9.3.7 Multi-rate multi-optima OU motion models (OUMV) Next let’s fit an OUMV model. These models allow different \\(\\sigma^2\\) values and different trait optima or long-term mean values for different evolutionary regimes but the same \\(\\alpha\\). Here the evolutionary regimes are the ecomorphs. We fit the model as follows: # Fit OUMV model OUMV &lt;- OUwie(mytree, headw, model = &quot;OUMV&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the ## determinant and inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Let’s look at the results. OUMV ## ## Fit ## lnL AIC AICc BIC model ntax ## -44.76218 111.5244 113.2844 145.4879 OUMV 162 ## ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha 1.2723092 1.2723092 1.2723092 1.2723092 1.2723092 ## sigma.sq 0.3145519 0.1694205 0.0846562 0.4264903 0.2239952 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 2.56411043 2.07487154 1.63299692 2.3576922 2.32882686 ## se 0.05469608 0.07789733 0.04483435 0.0571418 0.05008628 ## ## ## Half life (another way of reporting alpha) ## Aquatic Aquatic Burrowing Burrowing Semiaquatic ## 0.5447946 0.5447946 0.5447946 0.5447946 ## Terrestrial ## 0.5447946 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) and \\(\\alpha\\). \\(\\alpha\\) (and the Half life of \\(\\alpha\\)) are the same across the whole tree in OUMV, but \\(\\sigma^2\\) varies for each ecomorph, with highest rates of log head width evolution in the semi-aquatic and aquatic species. In the Optima section we have an estimate for the long-term mean for log head width for each ecomorph. As for the OUM model, the value for Burrowing species is quite a lot lower than for the other ecomorphs, perhaps reflecting evolution towards narrower heads in that ecomorph? 9.3.8 Multi-alpha multi-optima OU motion models (OUMA) The OUMA models allow different \\(\\alpha\\) values and different trait optima or long-term mean values for different evolutionary regimes but the same \\(\\sigma^2\\) across the whole tree. To fit the model: OUMA &lt;- OUwie(mytree, headw, model = &quot;OUMA&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the ## determinant and inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Let’s look at the results. OUMA ## ## Fit ## lnL AIC AICc BIC model ntax ## -94.03345 210.0669 211.8269 244.0305 OUMA 162 ## ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha 0.04231866 0.02561920 0.05001181 0.07805285 0.03983739 ## sigma.sq 0.02650006 0.02650006 0.02650006 0.02650006 0.02650006 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 2.6039134 1.0229185 1.062951 2.2806802 2.4086081 ## se 0.2073386 0.8027084 0.293388 0.1309269 0.3975973 ## ## ## Half life (another way of reporting alpha) ## Aquatic Aquatic Burrowing Burrowing Semiaquatic ## 16.379234 27.055769 13.859671 8.880485 ## Terrestrial ## 17.399412 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) and \\(\\alpha\\). \\(\\sigma^2\\) is the same across the whole tree in OUMA, but \\(\\alpha\\) (and the Half life of \\(\\alpha\\)) varies for each ecomorph, with highest pull back to the long-term mean of log head width evolution in the aquatic burrowing species. In the Optima section we have an estimate for the long-term mean for log head width for each ecomorph. The value for Burrowing and Aquatic burrowing species is lower than for the other ecomorphs, perhaps reflecting evolution towards narrower heads in these ecomorphs? 9.3.9 Multi-rate multi-optima OU motion models (OUMVA) Finally, OUMVA models allow us to vary everything! We fit different \\(\\sigma^2\\) and \\(\\alpha\\) values and different trait optima or long-term mean values for different evolutionary regimes. We don’t have enough data to fit this model but I’ve included it for completeness. It takes a while to run… OUMVA &lt;- OUwie(mytree, headw, model = &quot;OUMVA&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the ## determinant and inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Let’s look at the results. OUMVA ## ## Fit ## lnL AIC AICc BIC model ntax ## -88.49131 206.9826 210.2703 253.2966 OUMVA 162 ## ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha 0.01204103 0.0807844561 0.055242542 0.0609966 0.059248568 ## sigma.sq 0.03939928 0.0007726168 0.003255536 0.0142240 0.004025552 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 2.5805087 1.9761178 1.3837697 2.2449803 2.360143 ## se 0.4046245 0.1039313 0.1606891 0.1499996 0.135139 ## ## ## Half life (another way of reporting alpha) ## Aquatic Aquatic Burrowing Burrowing Semiaquatic ## 57.565458 8.580205 12.547344 11.363702 ## Terrestrial ## 11.698969 ## ## Arrived at a reliable solution The Rates section shows how \\(\\sigma^2\\) and \\(\\alpha\\) vary for each ecomorph, and in the Optima section we have an estimate for the long-term mean for log head width for each ecomorph. It would not be sensible to over-interpret these results given the complexity of the model and the relative paucity (n = 162) of the data. Above I included code for all of the complex models discussed in the Primer. However, it is likely that the complexity of some of these models is greater than the information contained within the data. As a result one or more parameters may be poorly estimated. Always check parameter estimates from your models to ensure that they make biological sense. If you don’t check, you might unknowingly pick a poor model with incorrect biological interpretations. The more complex your models the more likely this is. Beware! 9.3.10 Comparing models of evolution using AIC As we have done in the last few exercises, we’re going to compare models using AIC, \\(\\Delta\\)AIC and AIC weights (AICw). The “best” model is the one with the smallest AIC, with \\(\\Delta\\)AIC = 0 or with AICw closest to 1. # Extract AICc scores from the models aic.scores &lt;- setNames(c(BM$AICc, OU$AICc, BMS$AICc, OUM$AICc, OUMV$AICc, OUMA$AICc, OUMVA$AICc), c(&quot;BM&quot;, &quot;OU&quot;, &quot;BMS&quot;, &quot;OUM&quot;, &quot;OUMV&quot;, &quot;OUMA&quot;, &quot;OUMVA&quot;)) # Get aic weights aicw(aic.scores) ## fit delta w ## BM 446.85300 360.39183 5.519598e-79 ## OU 167.90063 81.43947 2.068444e-18 ## BMS 327.60252 241.14136 4.333301e-53 ## OUM 86.46117 0.00000 9.999985e-01 ## OUMV 113.28436 26.82319 1.497674e-06 ## OUMA 211.82690 125.36574 5.986532e-28 ## OUMVA 210.27030 123.80913 1.303729e-27 The best fitting model for the data is the OUM model, i.e. where there are different trait optima or long-term mean values for different ecomorphs but the same \\(\\sigma^2\\) and \\(\\alpha\\). A second look at the output for this model suggests that there is a rather strong pull towards the ecomorph optima for log head width, and that burrowing species have the narrowest heads. Does this make sense biologically? # Look at the output OUM ## ## Fit ## lnL AIC AICc BIC model ntax ## -35.86695 85.73389 86.46117 107.3471 OUM 162 ## ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha 9.094924 9.094924 9.094924 9.094924 9.094924 ## sigma.sq 1.679142 1.679142 1.679142 1.679142 1.679142 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 2.55900183 2.07636983 1.63753812 2.36487673 2.32107617 ## se 0.04635845 0.09160788 0.07368935 0.04202907 0.04994948 ## ## ## Half life (another way of reporting alpha) ## Aquatic Aquatic Burrowing Burrowing Semiaquatic ## 0.07621253 0.07621253 0.07621253 0.07621253 ## Terrestrial ## 0.07621253 ## ## Arrived at a reliable solution 9.4 Summary You should now know how to fit some of the more complex models of evolution in R. 9.5 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Using log body size (AdultBodyMass_g) as your continuous trait, and social status (SocialStatus) to define the selective regimes, fit (A) a multi-rate Brownian motion model and (B) an OU model with different long-term mean values for different evolutionary regimes but the same \\(\\sigma^2\\) and \\(\\alpha\\). Note that social status has two states: non-social (1) or social (2). Assume it is evolving according to an all rates different model. Then answer the following questions: Which is the best fitting model? If you were running these analyses for a publication, what additional models would you compare these models to? In the multi rate Brownian model, which social status state has the higher rate of log body mass evolution? Look at the parameter estimates of the multi peak OU model. Do you see anything worrying there? It might help to look at a histogram showing the body sizes of species in the non-social and the social categories. References "],["diversification-rate-analyses.html", "Chapter 10 Diversification rate analyses 10.1 Before you start 10.2 Preparation 10.3 Lineage through time plots and the \\(\\gamma\\) statistic 10.4 BAMM: Bayesian Analysis of Macroevolutionary Mixtures 10.5 Running BAMM 10.6 Looking at the output of BAMM using BAMMtools in R 10.7 Credible sets of shifts 10.8 Clade specific evolutionary rates 10.9 Rate-through-time analysis 10.10 Macroevolutionary cohort analysis 10.11 Assumptions and issues with BAMM 10.12 Summary 10.13 Practical exercises", " Chapter 10 Diversification rate analyses The aims of this exercise are to learn how to use R to perform some simple diversification rate analyses, and to analyse the output from a BAMM analysis. We will be using the diversification rates of dragonflies (Anisoptera) as an example. The tree comes from Letsch, Gottsberger, and Ware (2016b) and is available to download from Letsch, Gottsberger, and Ware (2016a). I’m only using one of their trees. If you want to see the full results check out Letsch, Gottsberger, and Ware (2016b)! 10.1 Before you start Open the 10-Diversification.RProj file in the 10-Diversification folder to open your R Project for this exercise. Make yourself a new R script for your code. You will also need to install the following packages: ape BAMMtools coda phytools viridis 10.2 Preparation To begin we need to load the packages for this practical. # Load the packages library(ape) library(BAMMtools) library(coda) library(phytools) library(viridis) To load the tree we will use read.tree. # Read in the tree dragonflytree &lt;- read.tree(&quot;data/dragonflies-tree.tre&quot;) # Check it loaded correctly str(dragonflytree) ## List of 4 ## $ edge : int [1:1042, 1:2] 523 524 525 525 526 527 527 526 528 528 ... ## $ edge.length: num [1:1042] 53.62 128.32 54.18 5.07 17.93 ... ## $ Nnode : int 521 ## $ tip.label : chr [1:522] &quot;Hypopetalia_pestilens&quot; &quot;Phyllopetalia_apicalis&quot; &quot;Ophiopetalia_diana&quot; &quot;Phyllopetalia_apollo&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Look at the tree plot(dragonflytree, show.tip.label = FALSE) Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary.tree(dragonflytree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(dragonflytree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(dragonflytree) ## [1] FALSE Oh dear, the tree is not ultrametric! But it looks ultrametric so we can fix this using the phytools function force.ultrametric. Note that this function is designed to deal with situations like this, but if your tree is genuinely non-ultrametric you should not use this function. # Force the tree to be ultrametric dragonflytree &lt;- force.ultrametric(dragonflytree) Why does a tree that looks ultrametric appear to be non-ultrametric? Most of the methods we use expect trees to be ultrametric, i.e. that all the tips line up, generally at the present day (time 0). Here we plotted the tree and it looks ultrametric, but when we check using is.ultrametric the answer returned is FALSE. What is going on? The tree is actually ultrametric, and will run in most analyses with R treating it as an ultrametric tree. The reason is.ultrametric tells us it is not ultrametric is related to rounding errors. When you save a tree file, it will save the branch lengths to a certain level of accuracy, but not always the full level of accuracy if your branch lengths have lots and lots of decimal places. When you read these trees back into R, a teeny tiny bit of the accuracy is lost which sometimes means that when R adds up the root-to-tip distances for each tip, they aren’t all exactly the same length, so therefore technically the tree is not ultrametric. For most implementations this tiny difference is not a big deal. A quick fix to this problem is to use the function force.ultrametric which essentially fudges the numbers to force the tree to be ultrametric. If your tree is genuinely non-ultrametric you should not use this function as it can introduce negative branch lengths which will break most functions you might want to use in R. Because these analyses only require a dated phylogeny and no additional data we do not need to do any extra data cleaning steps, unless you want to only look at a particular subset of the data. 10.3 Lineage through time plots and the \\(\\gamma\\) statistic Drawing lineage through time (LTT) plots is very easy in R using the phytools function ltt. This function will also calculate \\(\\gamma\\) statistic for you, but for this first example I have turned off that option using gamma = FALSE. # Draw LTT plot ltt(dragonflytree, gamma = FALSE) ## Object of class &quot;ltt&quot; containing: ## ## (1) A phylogenetic tree with 522 tips and 521 internal ## nodes. ## ## (2) Vectors containing the number of lineages (ltt) and ## branching times (times) on the tree. This looks like diversification in dragonflies is fairly constant through most of the phylogeny, except early in the tree where there are some larger bursts of speciation. There may also be a bit of slowdown in the later stages of the phylogeny too. If we wanted to we can also plot the tree and the LTT on the same plot as follows: # Plot LTT and tree ltt(dragonflytree, gamma = FALSE, show.tree = TRUE) ## Object of class &quot;ltt&quot; containing: ## ## (1) A phylogenetic tree with 522 tips and 521 internal ## nodes. ## ## (2) Vectors containing the number of lineages (ltt) and ## branching times (times) on the tree. We often also want to compare the observed LTT, to simulated LTTs assuming a pure-birth model. To do this we first need to simulate pure-birth trees that are the same age as our tree, and result in the same number of species. We can do this using the phytools function pbtree. This takes a few minutes to run… time for more cake/biscuits/tea/coffee/fresh air! I’m only using 10 simulations nsim = 10 below to save some time. For your own analyses, nsim = 100 (or higher) is likely to be give a better answer as it will explore more options. # Extract the number of species from the tree n_dragonflies &lt;- Ntip(dragonflytree) # Extract the total age of the tree age_dragonflies &lt;- max(nodeHeights(dragonflytree)) # Extract the speciation rate (number of new tips per unit time), assuming it follows an exponential curve (as expected under pure-birth) lambda_dragonflies &lt;-(log(n_dragonflies)-log(2))/age_dragonflies # Simulate 10 pure-birth trees using the above parameters sim_trees &lt;- pbtree(b = lambda_dragonflies, n = n_dragonflies, t = age_dragonflies, nsim = 10, quiet = TRUE, method = &quot;direct&quot;) We then use the ltt95 function to plot the 95% confidence intervals for the LTT based on the simulated set of pure-birth trees. This shows how much our observed LTT differs from the pure-birth null model (see Primer for more details). Note that if working with Bayesian posterior distributions of trees you can also use ltt95 to plot these. # Extract LTT plots for all simulations and plot the 95% confidence intervals ltt95(sim_trees, log = TRUE) # Add the original tree&#39;s LTT plot to the simulated data in red ltt(dragonflytree, add = TRUE, col = &quot;red&quot;, lwd = 2, gamma = FALSE, log = FALSE) ## Object of class &quot;ltt&quot; containing: ## ## (1) A phylogenetic tree with 522 tips and 521 internal ## nodes. ## ## (2) Vectors containing the number of lineages (ltt) and ## branching times (times) on the tree. It’s clear from this plot that the diversification of dragonflies is pretty close to the expectation under a pure-birth model. Fun with log transforms. The function ltt95 plots log number of lineages on the y-axis, but shows the real numbers of lineages on the y axis tick labels and spreads them out, rather than the actual logged values. This is fine until we try to add our original LTT plot from ltt back onto the graph! If we do that with log = TRUE in the ltt function, the line plots in completely the wrong place! A counter-intuitive solution to this, as shown in the code above, is to use log = FALSE instead which gives the correct plot! Finally, we can also use ltt to extract the value of the \\(\\gamma\\) statistic (Pybus and Harvey 2000): # Extract gamma ltt(dragonflytree, gamma = TRUE, plot = FALSE) ## Object of class &quot;ltt&quot; containing: ## ## (1) A phylogenetic tree with 522 tips and 521 internal ## nodes. ## ## (2) Vectors containing the number of lineages (ltt) and ## branching times (times) on the tree. ## ## (3) A value for Pybus &amp; Harvey&#39;s &quot;gamma&quot; statistic of ## gamma = -5.9763, p-value = 0. \\(\\gamma = -5.9763\\), and is significantly different from a pure-birth model of constant speciation rates (\\(p = 0\\), i.e. \\(p &lt; 0.001\\)). This confirms our suspicions from looking at the LTT plots above that dragonfly diversification rates have significantly decreased through time. 10.4 BAMM: Bayesian Analysis of Macroevolutionary Mixtures The BAMM part of this practical is based on the Rabosky lab’s excellent resource for using BAMM found at http://bamm-project.org/index.html. I highly recommend reading it, especially if you want to use BAMM on your own data. BAMM (Bayesian Analysis of Macroevolutionary Mixtures; Rabosky (2014), Rabosky et al. (2014)) identifies discrete shifts in diversification rates at nodes of a tree (it can also investigate trait evolution but we will focus on diversification rates here), i.e places where diversification rates speed up or slow down. BAMM looks for rate shifts across the whole tree, so it can find one or more shifts. It does this using reversible jump Markov Chain Monte (MCMC) methods to automatically explore a vast universe of possible models (reversible jump MCMC is a special kind of MCMC algorithm; see Rabosky (2014) for details). It is biased towards simpler models (a common tactic in most evolutionary models, e.g. parsimony) so rarely results in lots of rate shifts. For each MCMC run (generally over 1 million iterations are run in these analyses), BAMM simulates speciation and extinction along the tree, extracts the number of rate shifts, and then works out the probability of that particular combination of rate shifts occurring. The resulting BAMM outputs are a sample of all possible combinations of rates and rate shifts across all models, in proportion to their posterior probability. The posterior, or distribution of results, from BAMM will thus contain lots of different combinations of rates and rate shifts, but those that occur more often across all the models will appear more often than those that occur rarely. In the posterior, we call each of these possible combinations distinct shift configurations. These are the most probable configuration of shifts from one model from the posterior. For example, one shift configuration may be a speed up at node 34 and a slow down at node 22 on model 10000. Each model in the posterior might have a different distinct shift configuration, or they might all be very similar. It depends on the dataset. The number of possible distinct shift configurations is huge. Eventually, if you ran BAMM for for long enough you’d find a shift on every branch in the tree (because the branches can show shifts due to the effect of the prior alone). We know that all the distinct shift configurations are possible but they aren’t equally probable. As mentioned above some may be common, and others rare. We need some way of summarising thousands of models, and taking this into account. There are two main approaches (and I’ll show you how to extract both from your BAMM outputs below). Overall best shift configuration You can get this by looking at the maximum a posteriori (MAP) probability shift configuration, i.e. the one that appeared the most often in the posterior. This is a bit like using a consensus tree in phylogenetics. However, for most real datasets, the best rate shift configuration is merely one of a large number of possible rate shift configurations that have similar probabilities. So this method is not preferred (also if you’ve bothered to fit over 1 million models it seems pointless to just get one result!). Credible shift sets An alternative way to present the results is to summarise all the distinct shift configurations. However, not all distinct shift configurations are going to be significant. Therefore, BAMM splits shifts into “important” ones that help explain the data (core shifts) and ones that are less important (or likely just due to priors) using marginal odds ratios. Specifically, BAMM computes the marginal odds ratio for each rate shift for every branch in the phylogeny. It then excludes all shifts that are unimportant using a pre-determined threshold value (usually 5). The remaining shifts are the credible shift set. These are usually reported in papers using BAMM. BAMM is easy to run which makes it a slightly dangerous! It’s easy to run with no idea of what you are doing or why. If you want to use it on your own data you’ll need to do a lot of reading and thinking first. Below I present a very simplified version so you can get a taste of what it does. 10.5 Running BAMM BAMM is a command line program written in C++. Analysis and visualization of the results are performed using the R package BAMMtools (Rabosky et al. 2014). We will not run BAMM itself in this practical, we will just use BAMMtools in R. Running BAMM using C++. BAMM is a command line program written in C++. To run BAMM, you need to download the program first, then you run it via the command line (Terminal for Macs or something like cygwin in Windows). Your command line window will need to be opened from a folder containing the following files: Your phylogeny A control file (there is an example with the datasets) Your data - if doing trait evolution analyses The control file specifies lots of information about how the BAMM model should be run, including MCMC settings (e.g. number of generations, number of chains, acceptance rates), the priors (including your expectation for the number of shifts, rates of speciation and extinction) and the initial values of the parameters. It is crucial that these settings are carefully thought through, and that multiple different combinations are tried to make sure models are converging etc. To get a sensible starting set of priors you can use the BAMMtools function setBAMMpriors. Running BAMM is then as simple as running this in the command line: bamm -c control.txt Assuming your control file is called control.txt, and your command line is running this in the folder containing the control file and your tree. 10.6 Looking at the output of BAMM using BAMMtools in R BAMM can take a long time to run for large datasets, and outputs several files with lots of different output. Rather than running BAMM here we are just going to investigate its outputs using the R package BAMMtools. I have created a control file for the dragonfly data (dragonflies_control.txt) and run this with BAMM. The output files we will use are: dragonflies_chain_swap.txt\" dragonflies_event_data.txt\" dragonflies_mcmc_out.txt\" dragonflies_run_info.txt\" Remember that BAMM is a Bayesian method, so rather than giving the one most likely result (like we get in maximum likelihood analyses), BAMM outputs a distribution of results, often containing thousands of results, that we call the posterior distribution (or just the posterior). 10.6.1 Assessing MCMC convergence Before we look at any of the exciting results, we need to check if our MCMC run actually converged. You should be familiar with this from building Bayesian phylogenies. Luckily BAMM is really helpful in what it outputs, so we can do this quite easily by looking at the dragonflies_mcmc_out.txt file. # Read in the file mcmc &lt;- read.csv(&quot;data/dragonflies_mcmc_out.txt&quot;) # Take a look at the plot plot(mcmc$logLik ~ mcmc$generation) This gives us a vague idea of whether your run has converged. SPOILER alert, it has because I played around with the parameters in BAMM until it did, and used the same priors as Letsch, Gottsberger, and Ware (2016b). Again, as with Bayesian phylogenies, we next want to discard some runs as burnin. Let’s discard the first 10% of samples. # What is 10% of rows? burnstart &lt;- floor(0.1 * nrow(mcmc)) # Remove the first 10% from the runs postburn &lt;- mcmc[burnstart:nrow(mcmc), ] We can also use the coda library to check the effective sample sizes (ESS) of the log-likelihood and the number of shift events present in each sample. # Extract ESS for the number of rate shifts parameter effectiveSize(postburn$N_shifts) ## var1 ## 273.7424 # Extract ESS for the log likelihood effectiveSize(postburn$logLik) ## var1 ## 219.238 In general, we want these to be at least 200, and larger for small datasets. Note that these are standard procedures for any Bayesian analysis, not anything magical invented just for BAMM. OK great now we know that our analysis converged we can look at the cool stuff. 10.6.2 Analysis of rate shifts in the dragonfly phylogeny We first need to load our phylogeny and the output of BAMM called the event data file. This contains most of the outputs we’ve mentioned above, such as the branch-specific speciation rates, positions of rate shifts etc. Note that we again exclude the first 10% of samples as burn-in using burnin = 0.1. # Read in the tree (if you haven&#39;t already) tree &lt;- read.tree(&quot;data/dragonflies-tree.tre&quot;) # This step may take a couple of minutes with a big dataset. edata &lt;- getEventData(tree, eventdata = &quot;data/dragonflies_event_data.txt&quot;, burnin = 0.1) ## Reading event datafile: data/dragonflies_event_data.txt ## ........... ## Read a total of 2501 samples from posterior ## ## Discarded as burnin: GENERATIONS &lt; 2490000 ## Analyzing 2252 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence The message this produces tells you how many samples were read and how many excluded as burnin. 10.6.2.1 How many rate shifts? The first thing we might like to know is how many rate shifts occur in our tree? We can do this using our event data (edata) to look at the posterior probabilities of models sampled by BAMM. # Look at the posterior for number of shifts summary(edata) ## ## Analyzed 2252 posterior samples ## Shift posterior distribution: ## ## 1 0.0630 ## 2 0.2100 ## 3 0.2600 ## 4 0.2300 ## 5 0.1400 ## 6 0.0600 ## 7 0.0240 ## 8 0.0100 ## 9 0.0044 ## 10 0.0018 ## ## Compute credible set of shift configurations for more information: ## See ?credibleShiftSet and ?getBestShiftConfiguration This should show the posterior probabilities of each number of rate shifts observed during simulation of the posterior. This doesn’t tell us where they occur on the tree, just how many there are, and what their probability was. Here it looks like 3 shifts occurred most often, but with a range in number of shifts from 0 to 10. 10.6.3 Mean phylorate plot Next we might want to visualise these results on our tree. Mean phylorate plots are a way of visualizing the mean, model-averaged diversification rates along every branch of the tree. We can plot one using plot.bammdata. # Plot mean phylorate plot with legend and slighting larger line width (lwd) plot.bammdata(edata, legend = TRUE, lwd = 2) # If you want to make a large PDF version # pdf(&quot;data/dragonfly-phylorate-plot.pdf&quot;, height = 50, width = 50) # plot.bammdata(edata, lwd = 2, legend = TRUE, cex = 0.5, labels = TRUE) # dev.off() High rates are in red or yellow, and the low rates in blue. You can add the option labels = TRUE to get tip labels, but they’re really hard to read so you might need to look at a normal tree plot plot(tree, cex = 0.5) to see which species are involved here. I’ve provided a large PDF version of the tree in the folder where you can zoom in to see the details. In our dragonflies we see low rates (dark blues and blues) in most groups, but with higher rates near the base of the Libellulidae (the family that contains skimmers or perchers and their relatives, including my favourite the globe skimmer Pantala flavescens), and in one clade within the Libellulidae. It seems like there was a burst of diversification in the history of the clade, but rates have mostly slowed towards the present. See Letsch, Gottsberger, and Ware (2016b) for a much more thorough interpretation of these results. Help I get errors and no plots! Sometimes when working with these BAMMtools plots I’ve been getting an error Warning in gzfile(file, “wb”) : cannot open compressed file followed by a lot more red text. This appears to be a memory issue, as it happens when I’m making my laptop do something complex. It might only be on Mac, and/or only in RMarkdown, but if it happens when you try to plot things just try again. That works for me! We can also plot with slightly nicer colour-blind friendly colours from the package viridis (have a look at the options and choose your favourite). # Plot mean phylorate plot with a different colour palette (pal) taken # from the viridis package plot.bammdata(edata, lwd = 2, pal = plasma(4)) 10.6.4 Best single distinct shift configuration To extract the overall best distinct shift configuration, we use the maximum a posteriori (MAP) probability shift configuration, i.e. the one that appeared the most often in the posterior, as follows. # What is the single best rate shift configuration? best &lt;- getBestShiftConfiguration(edata, expectedNumberOfShifts = 1) ## Processing event data from data.frame ## ## Discarded as burnin: GENERATIONS &lt; 0 ## Analyzing 1 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence We can plot this as follows: # Plot mean phylorate plot for single best rate shift configuration plot.bammdata(best, lwd = 2, pal = plasma(4)) # Add the positions of the rate shifts addBAMMshifts(best, cex = 1.5, bg = &quot;white&quot;) The best single distinct shift configuration consists of two shifts, one on the branch leading to the Libellulidae, and one leading to a small clade within Libellulidae. 10.7 Credible sets of shifts Using just one answer is not very desirable, so let’s look at the shifts from across the posterior. As described above, the number of possible distinct shift configurations is huge, but not all these shifts are going to be significant. BAMM computes the marginal odds ratio for each a rate shift for every branch in the phylogeny. It then excludes all shifts that are unimportant using a pre-determined threshold value (usually 5). The remaining shifts are the credible shift set. To extract the credible shift set for our data, we can use the BAMMtools function credibleShiftSet. # Extract 95 % credible set of rate shift configurations css &lt;- credibleShiftSet(edata, expectedNumberOfShifts = 1, threshold = 5, set.limit = 0.95) # Look at the summary summary(css) ## ## 95 % credible set of rate shift configurations sampled with BAMM ## ## Distinct shift configurations in credible set: 516 ## ## Frequency of 9 shift configurations with highest posterior probability: ## ## ## rank probability cumulative Core_shifts ## 1 0.06216696 0.06216696 2 ## 2 0.05772647 0.11989343 3 ## 3 0.05461812 0.17451155 1 ## 4 0.04440497 0.21891652 2 ## 5 0.03507993 0.25399645 3 ## 6 0.02841918 0.28241563 2 ## 7 0.02664298 0.30905861 3 ## 8 0.02486679 0.33392540 2 ## 9 0.02353464 0.35746004 3 ## ## ...omitted 507 additional distinct shift configurations ## from the credible set. You can access the full set from your ## credibleshiftset object Here we see that there are 516 distinct shift configurations in our posterior. This highlights why using BAMM is a good idea - we can incorporate the distribution of results rather than giving just one best answer. We also see the nine of these account that for most of the probability of the data. In this case it’s only ~36%. BAMMtools chooses the first nine because it’s a good number to plot. You can plot fewer, to get six plots for example, using plot.credibleshiftset(css, plot.max = 6). We can generate phylorate plots for each of these shift configurations using plot.credibleshiftset # Plot top 9 from 95 % credible set of rate shift configurations plot.credibleshiftset(css) ## Omitted 507 plots The text above each phylorate plot gives the posterior probability of each shift configuration. Because many samples from the posterior can be assigned to each distinct shift configuration, the phylorate plots generated by plot.credibleshiftset are model-averaged mean rate parameters across all samples assignable to a given configuration. The shifts themselves are indicated with circles on branches, with the circle size being related to the probability of that particular shift. Note: this will set the plotting window to plot nine plots, so we need to take it back to the default of one plot using: # Return plot window to one plot only par(mfrow = c(1,1)) 10.8 Clade specific evolutionary rates We might also be interested in seeing if particular clades have different rates of speciation or extinction. This can be done in BAMMtools using the function getCladeRates, which computes the average rate for the chosen clade. Here we might be interested in seeing how different the rates are in our fastest clade, the Libellulidae, compared to the rest of our species. First we can look at the average rate across the whole tree using getCladeRates. # Extract speciation and extinction rates from the whole posterior allrates &lt;- getCladeRates(edata) allrates is a list with speciation and extinction rates, with the mean rate across all dragonflies for each sample in the posterior. We can extract the mean speciation rate for our tree and estimate the 90% highest posterior density (HPD) as follows. # Calculate overall mean speciation rate mean(allrates$lambda) ## [1] 0.02012068 # Calculate 90% highest posterior density for speciation rate quantile(allrates$lambda, c(0.05, 0.95)) ## 5% 95% ## 0.01792644 0.02336377 To get the rates for a specific clade, we just specify the node leading to that clade. In the our dragonfly example, node 771 is the node number of the Libellulidae clade (you can find identify node numbers using plot.phylo and nodelabels from the ape package). We can estimate the mean speciation rates for Libellulidae as follows: # Extract speciation and extinction rates for Libellulidae lib_rates &lt;- getCladeRates(edata, node = 771) # Calculate mean speciation rate for Libellulidae mean(lib_rates$lambda) ## [1] 0.02347474 # Calculate 90% highest posterior density for speciation rate for Libellulidae quantile(lib_rates$lambda, c(0.05, 0.95)) ## 5% 95% ## 0.01988954 0.02952452 As expected this is slightly higher than for dragonflies as a whole. To get the rates for everything but Libellulidae, we do the same thing, but add the argument nodetype = \"exclude\": # Extract speciation and extinction rates for everything but Libellulidae non_lib_rates &lt;- getCladeRates(edata, node = 771, nodetype = &quot;exclude&quot;) # Calculate mean speciation rate for everything but Libellulidae mean(non_lib_rates$lambda) ## [1] 0.01724914 # Calculate 90% highest posterior density for speciation rate for everything but Libellulidae quantile(non_lib_rates$lambda, c(0.05, 0.95)) ## 5% 95% ## 0.01497214 0.02008319 As expected this is slightly lower than for dragonflies as a whole, and quite a bit lower than for Libellulidae. Note that these are mean time-averaged clade-specific rates. If diversification rates have changed dramatically through the history of a particular clade, a single overall mean rate might not be particularly informative. This is likely true for Libellulidae which appears to have much higher rates at the base of the clade than towards the tips. 10.9 Rate-through-time analysis We may also want to visualise how rates of speciation change through time on our tree. We can do this by plotting a rate-through-time curve using the plotRateThroughTime function. # Plot speciation rate through time # This may take a minute or so plotRateThroughTime(edata, ratetype = &quot;speciation&quot;) The red line is the average speciation rate, with density shading showing the confidence intervals. The hump in the centre of the plot likely represents the higher rates at the base of the Libellulidae You can also use plotRateThroughTime to plot speciation through time curves for just a portion of your phylogeny. Here we can compare the whole tree, just Libellulidae (node 771), and everything but the Libellulidae. Note that to make the comparison easier I’ve set the y-axis limits using ylim so they are the same in all the plots. # Make the plotting window show two plots par(mfrow = c(1,3)) # This may take a minute or so # Plot speciation rate through time for all dragonflies plotRateThroughTime(edata, ylim = c(0, 0.2)) # Plot speciation rate through time for Libellulidae plotRateThroughTime(edata, node = 771, nodetype = &quot;include&quot;, ylim = c(0, 0.2)) # Plot speciation rate through time for everything but Libellulidae plotRateThroughTime(edata, node = 771, nodetype = &quot;exclude&quot;, ylim = c(0, 0.2)) # Return the plotting window to one plot par(mfrow = c(1,1)) We can also use plotRateThroughTime to plot the extinction rate, using ratetype = \"extinction\" or net diversification rate using ratetype = \"netdiv\". # Plot net diversification rate through time # This may take a minute or so # I&#39;ve also changed the colours of the line and confidence intervals plotRateThroughTime(edata, ratetype = &quot;netdiv&quot;, avgCol = &quot;darkgreen&quot;, intervalCol = &quot;palegreen&quot;) 10.10 Macroevolutionary cohort analysis A final nice feature of BAMMtools that we’ll play with here (there are others too) is the ability to easily perform a macroevolutionary cohort analysis (Rabosky et al. 2014). These are a good way of summarising which species/clades share correlated macroevolutionary dynamics i.e. similar rates of speciation etc. The basic idea is to visualize the pairwise probabilities that any two species share a common macroevolutionary rate regime. First we generate a cohort matrix, which contains the pairwise probabilities of shared macroevolutionary dynamics. We then pass this to the cohorts function, which generates the plot. cmat &lt;- getCohortMatrix(edata) cohorts(cmat, edata) Each cell of the cohort matrix corresponds to a pair of tip taxa from the phylogeny. You read these plots by drawing an imaginary line between any two tips of the tree - the colour of the matrix at their intersection is the probability that those taxa share a common rate dynamic. Species pairs that share a common rate dynamic are red, whereas species with different macroevolutionary dynamics are blue. This shows that Libellulidae and the other dragonflies have completely different macroevolutionary dynamics. Within each of these groups there is some variation, with certain clades being more similar to one another than others. For example, the small clade within Libellulidae (at the top of the phylogeny plot) that has a very high rate of evolution, has very different macroevolutionary dynamics to the other members of the Libellulidae. Check out this example with whales (http://bamm-project.org/bammgraph.html#whales-cohort) for an easier to interpret plot. And if you’re looking for a SciArt project, I always think these plots would make very lovely rugs with a slightly different colour scheme… 10.11 Assumptions and issues with BAMM Like all methods, BAMM has a number of important assumptions and issues. Second, the prior for the number of expected shifts will have a large effect on how many shifts are detected, particularly for long branches as the probability of seeing a shift due to the prior alone increases with branch length. To solve this BAMM estimates marginal odds ratios, scaling each marginal shift probability by the prior and branch length. You can (and should) check for this problem using the code below. # Plot the prior and the posterior plotPrior(mcmc, expectedNumberOfShifts = 1) There is some overlap, but it’s clear that the prior is different to the posterior, so this issue is not affecting our analyses. Predictions are better than post-hoc stories. BAMM is great, but it will often give answers you didn’t expect. It is not a good idea to just run a BAMM analysis and see what happens. Most phylogenies will contain some rate shifts, but if you don’t have hypotheses/predictions about what factors may influence diversification rates in your group then you’ll be stuck trying to invent reasons for these rate shifts after the fact. This is not a great way to do science, and can lead to some very odd conclusions if you’re just fishing around for ideas! Instead, thoroughly research your study group, think about why some species/groups/clades might diversify more rapidly than others, then run BAMM to see if your predictions are supported or not. Think about your sampling! Diversification rate analyses are powerful, exciting, and fairly easy to implement. As such they’re very tempting methods to use without really thinking carefully about the caveats, of which there are many! Incomplete sampling is a really big issue to consider. Sampling is generally incomplete and uneven; we never have every possible species in our phylogenies. If you only use living species, it is important to consider how extinct diversity may effect your conclusions. If you use living and fossil species you need to remember that for most groups the fossil record is patchy at best. If species are missing at random this is less of a problem, but if you’re missing a big chunk of diversity with a certain trait, or in a certain time period, your results may be meaningless at best, misleading at worst. 10.12 Summary You should now know how to plot LTT plots, calculate the \\(\\gamma\\) statistic, and analyses the outputs of BAMM using BAMMtools in R. 10.13 Practical exercises BAMMtools has a several inbuilt example datasets. For this practical exercise we will use the cetacean (whales; from Steeman et al. (2009)) and the ray-finned fishes (fishes; from Rabosky et al. (2013)) datasets. We load this data into R using: # Load data from BAMMtools data(whales) # this is the tree data(mcmc.whales) data(events.whales) # Add fishes data data(fishes) # this is the tree data(events.fishes) ## There is no `mcmc.fishes` file Then to use the whales data in analyses like our dragonfly example: whales_tree &lt;- whales whales_mcmc &lt;- mcmc.whales whales_edata &lt;- getEventData(whales, eventdata = events.whales, burnin = 0.1) ## Processing event data from data.frame ## ## Discarded as burnin: GENERATIONS &lt; 995000 ## Analyzing 1801 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence Other than this slight difference the rest of the code should work in exactly the same way. Load the whales and fishes trees and BAMM outputs data into R (there is no mcmc.fishes file). Then answer the following questions: How can we tell that the BAMM model for whales has converged? What is the effective sample size for number of shifts? What is the most common number of rate shifts in the posterior for the whales data? Plot the 95% credible set of rate shift configurations for whales. Plot the mean phylorate plot for fishes. What are the mean speciation rate and the 90% posterior density for mean speciation rate in fishes? References "],["critical-thinking-about-methods-and-analyses.html", "Chapter 11 Critical thinking about methods and analyses 11.1 How to critically evaluate a paper that uses phylogenetic comparative methods 11.2 Further reading", " Chapter 11 Critical thinking about methods and analyses Often it is tempting accept the results of papers at face value. They were published so they must be correct, right? Sadly no. Even the best papers have flaws. There may be problems with the data, method or interpretation of the results. Some of these are unavoidable, some reflect misunderstandings of the methods used, and others are just mistakes. Learning to critically read the scientific literature (or indeed any literature in this age of fake news!) is therefore a key skill to develop. As practice we will split into groups and critically evaluate recent papers using some of the methods we’ve worked with in this module. I’ll assign papers to everyone on the first day. Read the paper before class, and make notes of things you don’t understand or disagree with. I have provided some guidance of things to look for below. The question you should keep asking yourself throughout is given the data and methods, do I trust the conclusions of the paper? I know you’re all very busy and stressed so might be tempted to skip this session. That’s up to you obviously, but in feedback I’m often told this session is the most generally useful one of this module as it helps you think think carefully about how you read papers. This will be vital for your projects. We generally have a wide ranging discussion about publishing, ethics, writing in the active voice (please do this, the passive voice is the worst!), and all sorts of things. So even if you only find time to skim the paper I recommend coming along :). 11.1 How to critically evaluate a paper that uses phylogenetic comparative methods You should never take results from PCMs (or any other statistical analysis) at face value. When reading any paper it’s worth having a check list in your head of things to look out for. Below we’ve shared our version of this. Although it’s aimed at papers using PCMs, most of the questions can be used with any paper. It’s worth remembering that not everything you see in a paper is an author’s fault or choice. In some cases, editors and reviewers may suggest using PCMs where they are not appropriate. Glamour journals like Nature and Science will also often encourage authors to oversell their results. And of course we all make mistakes or change our minds from time to time. So remember to be gentle and kind to people at the same time as being brutal and cynical with papers! Logic/interpretation What questions does the paper address? Do the analyses/data actually answer the questions the paper is meant to be asking, or do they answer a different question? What are the conclusions? Do the analyses/data support the conclusions? Is importance of the conclusions exaggerated? Is the logic of the paper clear and justifiable, given the assumptions? Are there any flaws in the logic of the paper? Do you agree with how the results have been interpretted? Data What’s the sample size? Is it large enough to support the conclusions of the paper? How many species are missing from the analysis? Does this worry you? Is two species missing from a group of 50 species a problem? Can 50 species be used to make conclusions about a group containing thousands of species? Are species missing in a way which might influence the results? Would you be concerned if all species from one clade were missing? Are the species present well distributed across the phylogeny? Are fossil/extinct species considered? Would this influence the results/conclusions? How were the data collected? Could this bias the results at all? Are there biases in the age, sex, geographic locality etc. of species included? Do you think the data quality is high enough? Would other data have been better to answer this question? Methods Check the text carefully for caveats. These may appear in the introduction, methods, results or discussion. Were these dealt with or just mentioned? What are the assumptions/limitations of the method being used? These may be mentioned in the text, or you may need to dig into the literature to find them. Are the assumptions made reasonable? For example, a big assumption underlying all phylogenetic methods is that the phylogeny is correct. Do you agree? Be aware that some older methods may have been superseded by better methods. Be aware that sometimes there is debate in a community about the best method to use (e.g. the BAMM debate). Moving forwards What are the good things in the paper? Make sure that you don’t ignore the positive in your hunt for the negative! Do these ideas have other applications or extensions that the authors might not have thought of? How would you fix the flaws in this paper? 11.2 Further reading These papers involve critiques/reviews of some of the methods we’ve been learning about in this module. They may be helpful for some of the papers: Cooper et al. (2016), Cooper, Thomas, and FitzJohn (2016), Freckleton (2009), Losos (2011), Kamilar and Cooper (2013), Moore et al. (2016), Rabosky and Goldberg (2015). References "],["answers-to-practical-exercises.html", "Chapter 12 Answers to practical exercises 12.1 Diversity indices 12.2 Phylogenies 12.3 Preparation 12.4 Phylogenetic signal 12.5 PGLS 12.6 Models of evolution with continuous traits 12.7 Models of evolution with discrete traits 12.8 Beyond simple macroevolutionary models of trait evolution 12.9 Diversification", " Chapter 12 Answers to practical exercises Below are all the questions and answers to the practical exercises at the end of each exercise. 12.1 Diversity indices In the folder there is another (invented) dataset using British bats called bat-communities.csv. Read in the data, manipulate it as required by vegan, then answer the following questions. # Load packages library(vegan) library(picante) # Read in the dataset bat &lt;- read.csv(&quot;data/bat-communities.csv&quot;) # Create a matrix we can use with vegan bat.matrix &lt;- sample2matrix(bat) Which site has the fewest species? specnumber(bat.matrix) ## A B C D E F G H I J K ## 8 6 7 9 8 11 11 13 12 12 7 Site B How many different species are there in total? # How many unique species are there? length(unique(bat$Species[bat$Abundance &gt;0])) ## [1] 18 18 What is Simpson’s diversity index for Site J? # Simpson&#39;s index diversity(bat.matrix, index = &quot;simpson&quot;) ## A B C D E F G ## 0.8430769 0.7947061 0.7375510 0.8097758 0.8350592 0.8820984 0.8733518 ## H I J K ## 0.8922723 0.8825614 0.8198242 0.8394970 0.8198242 Draw a species accumulation curve for the bats and estimate the total number of species. If you round up numbers with decimal places, what is the maximum number of species estimated by any metric? # Fit species accumulation curve bat.curve &lt;- specaccum(bat.matrix, method = &quot;random&quot;, permutations = 1000) # Plot the curve plot(bat.curve, ci.type = &quot;poly&quot;, col = &quot;blue&quot;, ci.col = &quot;lightblue&quot;, lwd = 2, ci.lty = 0, xlab = &quot;number of sites&quot;, ylab = &quot;cumulative number of bat species&quot;) # Estimate diversity specpool(bat.matrix) ## Species chao chao.se jack1 jack1.se jack2 boot boot.se n ## All 18 18 0 18 0 16.52727 18.26721 0.4762132 11 18.267 + 0.476, i.e. 19 species in total 12.2 Phylogenies Read in the frog-tree.nex phylogeny from the folder. This comes from Feng et al. (2017). Then do the following: Read the tree into R. # Load packages library(ape) library(ggtree) library(tidyverse) # Read in the tree tree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Look at it tree ## ## Phylogenetic tree with 214 tips and 213 internal nodes. ## ## Tip labels: ## Ascaphus_truei_Ascaphidae, Leiopelma_hochstetteri_Leiopelmatidae, Alytes_obstetricans_Alytidae, Discoglossus_pictus_Alytidae, Barbourula_busuangensis_Bombinatoridae, Bombina_orientalis_Bombinatoridae, ... ## ## Rooted; includes branch lengths. Use R functions to determine: how many species are in the tree? # Look at the tree structure str(tree) ## List of 4 ## $ edge : int [1:426, 1:2] 215 216 217 218 219 220 221 222 223 224 ... ## $ edge.length: num [1:426] 0.166 0.114 0.102 0.4 0.133 ... ## $ Nnode : int 213 ## $ tip.label : chr [1:214] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Or the whole tree tree ## ## Phylogenetic tree with 214 tips and 213 internal nodes. ## ## Tip labels: ## Ascaphus_truei_Ascaphidae, Leiopelma_hochstetteri_Leiopelmatidae, Alytes_obstetricans_Alytidae, Discoglossus_pictus_Alytidae, Barbourula_busuangensis_Bombinatoridae, Bombina_orientalis_Bombinatoridae, ... ## ## Rooted; includes branch lengths. There are 214 tips is the tree fully resolved? # Check whether the tree is binary/fully resolved is.binary.tree(tree) ## [1] TRUE Yes is the tree rooted? # Check whether the tree is rooted is.rooted(tree) ## [1] TRUE Yes Use plot.phylo to plot the tree. Can you change the size of the tip labels? Can you make a fan-shaped plot? Can you change the colour of the tips and branches? # Plot the tree plot(tree, no.margin = TRUE, # to make sure it fills the whole space type = &quot;fan&quot;, # to make a fan tree cex = 0.6, # to reduce the tip label size (default = 1) tip.color = &quot;deeppink&quot;, # to change the tip colour edge.color = &quot;springgreen&quot;) # to change the branch colour # yuk! Save the tree to file as “mysuperdoopertree.nex” # Save the tree write.nexus(tree, file = &quot;data/mysuperdoopertree.nex&quot;) 12.3 Preparation In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data then prepare them for a PCM analysis. # Load packages library(ape) library(geiger) library(tidyverse) library(treeplyr) # Read in the tree primatetree &lt;- read.nexus(&quot;data/primate-tree.nex&quot;) # Look at the tree summary str(primatetree) ## List of 4 ## $ edge : int [1:446, 1:2] 227 228 229 230 231 232 233 234 234 235 ... ## $ edge.length: num [1:446] 4.95 17.69 19.65 8.12 4.82 ... ## $ Nnode : int 221 ## $ tip.label : chr [1:226] &quot;Allenopithecus_nigroviridis&quot; &quot;Cercopithecus_ascanius&quot; &quot;Cercopithecus_cephus&quot; &quot;Cercopithecus_cephus_cephus&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Plot the tree as a circular/fan phylogeny with small labels plot(primatetree, cex = 0.2, typ = &quot;fan&quot;, no.margin = TRUE) # Check whether the tree is binary # We want this to be TRUE is.binary.tree(primatetree) ## [1] FALSE # It is FALSE so make the tree binary: primatetree &lt;- multi2di(primatetree) # Check whether the tree is binary now... is.binary.tree(primatetree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(primatetree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE, but it is FALSE is.ultrametric(primatetree) ## [1] FALSE # Force ultrametric primatetree &lt;- force.ultrametric(primatetree) # Read in the data primatedata &lt;- read_csv(&quot;data/primate-data.csv&quot;) ## ## ── Column specification ─────────────────────────────────────────────────── ## cols( ## Order = col_character(), ## Family = col_character(), ## Binomial = col_character(), ## AdultBodyMass_g = col_double(), ## GestationLen_d = col_double(), ## HomeRange_km2 = col_double(), ## MaxLongevity_m = col_double(), ## SocialGroupSize = col_double(), ## SocialStatus = col_double() ## ) # Look at the data glimpse(primatedata) ## Rows: 77 ## Columns: 9 ## $ Order &lt;chr&gt; &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, … ## $ Family &lt;chr&gt; &quot;Atelidae&quot;, &quot;Atelidae&quot;, &quot;Atelidae&quot;, &quot;Pitheciidae… ## $ Binomial &lt;chr&gt; &quot;Ateles belzebuth&quot;, &quot;Ateles geoffroyi&quot;, &quot;Ateles … ## $ AdultBodyMass_g &lt;dbl&gt; 6692.42, 7582.40, 8697.25, 958.13, 558.00, 290.2… ## $ GestationLen_d &lt;dbl&gt; 138.20, 226.37, 228.18, 164.00, 153.99, 144.00, … ## $ HomeRange_km2 &lt;dbl&gt; 2.28000, 0.73000, 1.36000, 0.02000, 0.32000, 0.0… ## $ MaxLongevity_m &lt;dbl&gt; 336.0, 327.6, 453.6, 303.6, 214.8, 201.6, 181.2,… ## $ SocialGroupSize &lt;dbl&gt; 14.50, 42.00, 20.00, 2.95, 6.85, 8.55, 6.00, 20.… ## $ SocialStatus &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, … # Replace spaces with underscores in species names primatedata &lt;- primatedata %&gt;% mutate(Binomial = str_replace(string = Binomial, pattern = &quot; &quot;, replacement = &quot;_&quot;)) # Check it worked glimpse(primatedata) ## Rows: 77 ## Columns: 9 ## $ Order &lt;chr&gt; &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, … ## $ Family &lt;chr&gt; &quot;Atelidae&quot;, &quot;Atelidae&quot;, &quot;Atelidae&quot;, &quot;Pitheciidae… ## $ Binomial &lt;chr&gt; &quot;Ateles_belzebuth&quot;, &quot;Ateles_geoffroyi&quot;, &quot;Ateles_… ## $ AdultBodyMass_g &lt;dbl&gt; 6692.42, 7582.40, 8697.25, 958.13, 558.00, 290.2… ## $ GestationLen_d &lt;dbl&gt; 138.20, 226.37, 228.18, 164.00, 153.99, 144.00, … ## $ HomeRange_km2 &lt;dbl&gt; 2.28000, 0.73000, 1.36000, 0.02000, 0.32000, 0.0… ## $ MaxLongevity_m &lt;dbl&gt; 336.0, 327.6, 453.6, 303.6, 214.8, 201.6, 181.2,… ## $ SocialGroupSize &lt;dbl&gt; 14.50, 42.00, 20.00, 2.95, 6.85, 8.55, 6.00, 20.… ## $ SocialStatus &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, … # Check whether the names match in the data and the tree check &lt;- name.check(phy = primatetree, data = primatedata, data.names = primatedata$Binomial) # Look at check check ## $tree_not_data ## [1] &quot;Allenopithecus_nigroviridis&quot; ## [2] &quot;Allocebus_trichotis&quot; ## [3] &quot;Alouatta_caraya&quot; ## [4] &quot;Alouatta_sara&quot; ## [5] &quot;Aotus_azarae&quot; ## [6] &quot;Aotus_azarae_infulatus&quot; ## [7] &quot;Aotus_lemurinus_griseimembra&quot; ## [8] &quot;Aotus_nancymaae&quot; ## [9] &quot;Arctocebus_aureus&quot; ## [10] &quot;Arctocebus_calabarensis&quot; ## [11] &quot;Ateles_fusciceps&quot; ## [12] &quot;Ateles_geoffroyi_ornatus&quot; ## [13] &quot;Ateles_geoffroyi_vellerosus&quot; ## [14] &quot;Avahi_laniger&quot; ## [15] &quot;Avahi_occidentalis&quot; ## [16] &quot;Brachyteles_arachnoides&quot; ## [17] &quot;Bunopithecus_hoolock&quot; ## [18] &quot;Callicebus_donacophilus&quot; ## [19] &quot;Callithrix_(Mico)_emiliae&quot; ## [20] &quot;Callithrix_argentata&quot; ## [21] &quot;Callithrix_aurita&quot; ## [22] &quot;Callithrix_geoffroyi&quot; ## [23] &quot;Callithrix_humeralifera&quot; ## [24] &quot;Callithrix_kuhli&quot; ## [25] &quot;Callithrix_penicillata&quot; ## [26] &quot;Cercocebus_agilis&quot; ## [27] &quot;Cercocebus_atys&quot; ## [28] &quot;Cercocebus_torquatus&quot; ## [29] &quot;Cercopithecus_cephus_cephus&quot; ## [30] &quot;Cercopithecus_cephus_ngottoensis&quot; ## [31] &quot;Cercopithecus_diana&quot; ## [32] &quot;Cercopithecus_erythrogaster_erythrogaster&quot; ## [33] &quot;Cercopithecus_erythrotis&quot; ## [34] &quot;Cercopithecus_hamlyni&quot; ## [35] &quot;Cercopithecus_lhoesti&quot; ## [36] &quot;Cercopithecus_lowei&quot; ## [37] &quot;Cercopithecus_mona&quot; ## [38] &quot;Cercopithecus_petaurista&quot; ## [39] &quot;Cercopithecus_preussi&quot; ## [40] &quot;Cercopithecus_solatus&quot; ## [41] &quot;Cercopithecus_wolfi&quot; ## [42] &quot;Cheirogaleus_crossleyi&quot; ## [43] &quot;Chlorocebus_aethiops&quot; ## [44] &quot;Chlorocebus_pygerythrus&quot; ## [45] &quot;Chlorocebus_sabaeus&quot; ## [46] &quot;Chlorocebus_tantalus&quot; ## [47] &quot;Colobus_angolensis&quot; ## [48] &quot;Eulemur_albifrons&quot; ## [49] &quot;Eulemur_albocollaris&quot; ## [50] &quot;Eulemur_collaris&quot; ## [51] &quot;Eulemur_macaco_flavifrons&quot; ## [52] &quot;Eulemur_macaco_macaco&quot; ## [53] &quot;Eulemur_rubriventer&quot; ## [54] &quot;Eulemur_rufus&quot; ## [55] &quot;Eulemur_sanfordi&quot; ## [56] &quot;Euoticus_elegantulus&quot; ## [57] &quot;Galago_gallarum&quot; ## [58] &quot;Galago_zanzibaricus&quot; ## [59] &quot;Gorilla_gorilla_gorilla&quot; ## [60] &quot;Hapalemur_alaotrensis&quot; ## [61] &quot;Hapalemur_aureus&quot; ## [62] &quot;Hapalemur_griseus_griseus&quot; ## [63] &quot;Hapalemur_griseus_meridionalis&quot; ## [64] &quot;Hapalemur_occidentalis&quot; ## [65] &quot;Homo_sapiens&quot; ## [66] &quot;Hylobates_agilis&quot; ## [67] &quot;Hylobates_klossii&quot; ## [68] &quot;Hylobates_moloch&quot; ## [69] &quot;Hylobates_muelleri&quot; ## [70] &quot;Indri_indri&quot; ## [71] &quot;Leontopithecus_chrysomelas&quot; ## [72] &quot;Leontopithecus_chrysopygus&quot; ## [73] &quot;Lepilemur_aeeclis&quot; ## [74] &quot;Lepilemur_ankaranensis&quot; ## [75] &quot;Lepilemur_dorsalis&quot; ## [76] &quot;Lepilemur_edwardsi&quot; ## [77] &quot;Lepilemur_microdon&quot; ## [78] &quot;Lepilemur_mitsinjoensis&quot; ## [79] &quot;Lepilemur_randrianasoli&quot; ## [80] &quot;Lepilemur_ruficaudatus&quot; ## [81] &quot;Lepilemur_sahamalazensis&quot; ## [82] &quot;Lepilemur_seali&quot; ## [83] &quot;Lepilemur_septentrionalis&quot; ## [84] &quot;Lophocebus_aterrimus&quot; ## [85] &quot;Loris_lydekkerianus_grandis&quot; ## [86] &quot;Loris_lydekkerianus_malabaricus&quot; ## [87] &quot;Macaca_arctoides&quot; ## [88] &quot;Macaca_assamensis&quot; ## [89] &quot;Macaca_cyclopis&quot; ## [90] &quot;Macaca_hecki&quot; ## [91] &quot;Macaca_leonina&quot; ## [92] &quot;Macaca_maura&quot; ## [93] &quot;Macaca_nigra&quot; ## [94] &quot;Macaca_nigrescens&quot; ## [95] &quot;Macaca_ochreata&quot; ## [96] &quot;Macaca_ochreata_brunnescens&quot; ## [97] &quot;Macaca_pagensis&quot; ## [98] &quot;Macaca_siberu&quot; ## [99] &quot;Macaca_thibetana&quot; ## [100] &quot;Macaca_tonkeana&quot; ## [101] &quot;Mandrillus_leucophaeus&quot; ## [102] &quot;Microcebus_berthae&quot; ## [103] &quot;Microcebus_bongolavensis&quot; ## [104] &quot;Microcebus_danfossi&quot; ## [105] &quot;Microcebus_griseorufus&quot; ## [106] &quot;Microcebus_jollyae&quot; ## [107] &quot;Microcebus_lehilahytsara&quot; ## [108] &quot;Microcebus_lokobensis&quot; ## [109] &quot;Microcebus_mittermeieri&quot; ## [110] &quot;Microcebus_myoxinus&quot; ## [111] &quot;Microcebus_ravelobensis&quot; ## [112] &quot;Microcebus_sambiranensis&quot; ## [113] &quot;Microcebus_simmonsi&quot; ## [114] &quot;Microcebus_tavaratra&quot; ## [115] &quot;Nomascus_gabriellae&quot; ## [116] &quot;Nomascus_leucogenys&quot; ## [117] &quot;Nycticebus_coucang&quot; ## [118] &quot;Nycticebus_pygmaeus&quot; ## [119] &quot;Pan_troglodytes_schweinfurthii&quot; ## [120] &quot;Pan_troglodytes_troglodytes&quot; ## [121] &quot;Pan_troglodytes_verus&quot; ## [122] &quot;Papio_papio&quot; ## [123] &quot;Piliocolobus_badius&quot; ## [124] &quot;Pongo_abelii&quot; ## [125] &quot;Pongo_pygmaeus_pygmaeus&quot; ## [126] &quot;Presbytis_melalophos&quot; ## [127] &quot;Propithecus_coquereli&quot; ## [128] &quot;Propithecus_diadema&quot; ## [129] &quot;Propithecus_edwardsi&quot; ## [130] &quot;Propithecus_tattersalli&quot; ## [131] &quot;Pygathrix_nemaeus&quot; ## [132] &quot;Rhinopithecus_avunculus&quot; ## [133] &quot;Rhinopithecus_bieti&quot; ## [134] &quot;Rhinopithecus_brelichi&quot; ## [135] &quot;Rhinopithecus_roxellana&quot; ## [136] &quot;Rungwecebus_kipunji&quot; ## [137] &quot;Saguinus_geoffroyi&quot; ## [138] &quot;Saguinus_imperator&quot; ## [139] &quot;Saimiri_boliviensis_boliviensis&quot; ## [140] &quot;Saimiri_oerstedii&quot; ## [141] &quot;Trachypithecus_(Trachypithecus)_auratus&quot; ## [142] &quot;Trachypithecus_(Trachypithecus)_poliocephalus&quot; ## [143] &quot;Trachypithecus_cristatus&quot; ## [144] &quot;Trachypithecus_francoisi&quot; ## [145] &quot;Trachypithecus_johnii&quot; ## [146] &quot;Trachypithecus_phayrei&quot; ## [147] &quot;Trachypithecus_pileatus&quot; ## [148] &quot;Varecia_rubra&quot; ## [149] &quot;Varecia_variegata_variegata&quot; ## ## $data_not_tree ## character(0) # 149 species are in the tree but not the data # 0 species are in the data but not the tree # Combine and match the tree and data primatestuff &lt;- make.treedata(tree = primatetree, data = primatedata, name_column = &quot;Binomial&quot;) # Look at the tree summary primatestuff$phy ## ## Phylogenetic tree with 77 tips and 76 internal nodes. ## ## Tip labels: ## Cercopithecus_ascanius, Cercopithecus_cephus, Cercopithecus_mitis, Cercopithecus_neglectus, Cercopithecus_nictitans, Erythrocebus_patas, ... ## ## Rooted; includes branch lengths. # Look at the data glimpse(primatestuff$dat) ## Rows: 77 ## Columns: 8 ## $ Order &lt;fct&gt; Primates, Primates, Primates, Primates, Primates… ## $ Family &lt;fct&gt; Cercopithecidae, Cercopithecidae, Cercopithecida… ## $ AdultBodyMass_g &lt;dbl&gt; 3540.24, 3444.88, 5041.29, 5324.52, 5256.91, 796… ## $ GestationLen_d &lt;dbl&gt; 148.50, 169.51, 138.39, 172.07, 169.51, 167.20, … ## $ HomeRange_km2 &lt;dbl&gt; 0.16000, 0.24000, 0.10000, 0.06000, 1.15000, 28.… ## $ MaxLongevity_m &lt;dbl&gt; 339.6, 276.0, 325.2, 315.6, 276.0, 286.8, 370.8,… ## $ SocialGroupSize &lt;dbl&gt; 26.30, 11.00, 16.00, 4.50, 16.00, 28.00, 91.20, … ## $ SocialStatus &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 1, … ## There are 77 species in the tree and the data # Make a new column called tiplabel with the tip labels in it primatestuff$dat$tiplabel &lt;- primatestuff$phy$tip.label # Save tree as mytree mytree &lt;- primatestuff$phy # Save data as mydata mydata &lt;- primatestuff$dat # Force mydata to be a data frame mydata &lt;- as.data.frame(mydata) # Check mydata is now a dataframe str(mydata) ## &#39;data.frame&#39;: 77 obs. of 9 variables: ## $ Order : Factor w/ 1 level &quot;Primates&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Family : Factor w/ 15 levels &quot;Aotidae&quot;,&quot;Atelidae&quot;,..: 4 4 4 4 4 4 4 5 5 6 ... ## $ AdultBodyMass_g: num 3540 3445 5041 5325 5257 ... ## $ GestationLen_d : num 148 170 138 172 170 ... ## $ HomeRange_km2 : num 0.16 0.24 0.1 0.06 1.15 ... ## $ MaxLongevity_m : num 340 276 325 316 276 ... ## $ SocialGroupSize: num 26.3 11 16 4.5 16 28 91.2 1 1 1 ... ## $ SocialStatus : int 2 2 2 2 2 2 2 1 1 1 ... ## $ tiplabel : chr &quot;Cercopithecus_ascanius&quot; &quot;Cercopithecus_cephus&quot; &quot;Cercopithecus_mitis&quot; &quot;Cercopithecus_neglectus&quot; ... ## OPTIONAL # Make any required subsets of the tree/data ## OPTIONAL # Write the cleaned data to a new file # write_csv(mydata, path = &quot;data/clean-primate-data.csv&quot;) # Write the cleaned tree to a new file # write.nexus(mytree, file = &quot;data/clean-primate-tree.nex&quot;) 12.4 Phylogenetic signal In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in the previous exercise which should save you some time). Then use phylosig to answer the following questions: # Load the packages library(ape) library(geiger) library(treeplyr) library(caper) library(tidyverse) library(phytools) ### Prepare the tree and the data as shown in the Preparation answer above ### ### This should mean you now have mydata and mytree ready to work with ### What is \\(\\lambda\\) for log gestation length? # First create logGestation containing just log gestation length values logGestation &lt;- log(pull(mydata, GestationLen_d)) # Give log Eye names = species names at the tips of the phylogeny names(logGestation) &lt;- mydata$tiplabel # Look at the first few rows head(logGestation) ## Cercopithecus_ascanius Cercopithecus_cephus Cercopithecus_mitis ## 5.000585 5.132912 4.930076 ## Cercopithecus_neglectus Cercopithecus_nictitans Erythrocebus_patas ## 5.147901 5.132912 5.119191 # Estimate lambda lambdaGestation &lt;- phylosig(mytree, logGestation, method = &quot;lambda&quot;, test = TRUE) # Look at the results lambdaGestation ## ## Phylogenetic signal lambda : 0.948326 ## logL(lambda) : 34.9204 ## LR(lambda=0) : 89.026 ## P-value (based on LR test) : 3.89649e-21 0.948 What is K for log gestation length? # Estimate Blomberg’s *K* KGestation &lt;- phylosig(mytree, logGestation, method = &quot;K&quot;, test = TRUE, nsim = 1000) # Look at the results KGestation ## ## Phylogenetic signal K : 0.775777 ## P-value (based on 1000 randomizations) : 0.001 0.776 What is D for social status? # Prepare the data for use in caper primate &lt;- comparative.data(phy = mytree, data = mydata, names.col = tiplabel, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE) # Force the phylogeny to have polytomies again nrather than zero length branches primate$phy &lt;- di2multi(primate$phy) # Estimate D Dsocial &lt;- phylo.d(data = primate, names.col = tiplabel, binvar = SocialStatus, permut = 1000) # Look at the output Dsocial ## ## Calculation of D statistic for the phylogenetic structure of a binary variable ## ## Data : mydata ## Binary variable : SocialStatus ## Counts of states: 1 = 14 ## 2 = 63 ## Phylogeny : mytree ## Number of permutations : 1000 ## ## Estimated D : -0.7228336 ## Probability of E(D) resulting from no (random) phylogenetic structure : 0 ## Probability of E(D) resulting from Brownian phylogenetic structure : 0.969 ~ -0.72, this is a randomisation test so may vary 12.5 PGLS In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Let’s investigate the relationship between gestation length in Primates and their body size. Theory leads us to believe that bigger mammals have longer gestation lengths (compare mice to elephants), but is this true in Primates? Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit a PGLS model to investigate the relationship between log gestation length (y = log(GestationLen_d)) and log body size (x = log(AdultBodyMass_g)) in Primates. Don’t forget to look at the model diagnostics! # Load the packages library(ape) library(geiger) library(treeplyr) library(caper) library(tidyverse) ### Prepare the tree and the data as shown in the Preparation answer above ### ### This should mean you now have mydata and mytree ready to work with ### # Prepare the data for use in caper primate &lt;- comparative.data(phy = mytree, data = mydata, names.col = tiplabel, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE) # Check the list of dropped species is what you expected primate$dropped$tips ## character(0) primate$dropped$unmatched.rows ## character(0) # Fit a PGLS model model.pgls &lt;- pgls(log(GestationLen_d) ~ log(AdultBodyMass_g), data = primate, lambda = &quot;ML&quot;, bounds = list(lambda = c(0.01, 1))) ### Model diagnostics # Make a plotting window with 4 panes as there are four plots par(mfrow = c(2, 2)) # Now plot the model diagnostics plot(model.pgls) # Return the plot window to one pane for later plotting par(mfrow = c(1, 1)) # Look at the model outputs summary(model.pgls) ## ## Call: ## pgls(formula = log(GestationLen_d) ~ log(AdultBodyMass_g), data = primate, ## lambda = &quot;ML&quot;, bounds = list(lambda = c(0.01, 1))) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.097244 -0.019277 -0.001562 0.009037 0.050542 ## ## Branch length transformations: ## ## kappa [Fix] : 1.000 ## lambda [ ML] : 0.892 ## lower bound : 0.010, p = 3.3196e-14 ## upper bound : 1.000, p = 0.00046393 ## 95.0% CI : (0.753, 0.967) ## delta [Fix] : 1.000 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.290229 0.160355 26.7546 &lt; 2.2e-16 *** ## log(AdultBodyMass_g) 0.104864 0.019628 5.3426 9.479e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.0261 on 75 degrees of freedom ## Multiple R-squared: 0.2757, Adjusted R-squared: 0.266 ## F-statistic: 28.54 on 1 and 75 DF, p-value: 9.479e-07 # Plot the results ggplot(mydata, aes(x = log(AdultBodyMass_g), y = log(GestationLen_d))) + geom_point() + geom_abline(slope = coefficients(model.pgls)[2], intercept = coefficients(model.pgls)[1]) + theme_bw() Then answer the following questions. What is the maximum likelihood estimate of \\(\\lambda\\) in the model? # Look at the model outputs. Lambda is near the middle summary(model.pgls) ## ## Call: ## pgls(formula = log(GestationLen_d) ~ log(AdultBodyMass_g), data = primate, ## lambda = &quot;ML&quot;, bounds = list(lambda = c(0.01, 1))) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.097244 -0.019277 -0.001562 0.009037 0.050542 ## ## Branch length transformations: ## ## kappa [Fix] : 1.000 ## lambda [ ML] : 0.892 ## lower bound : 0.010, p = 3.3196e-14 ## upper bound : 1.000, p = 0.00046393 ## 95.0% CI : (0.753, 0.967) ## delta [Fix] : 1.000 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.290229 0.160355 26.7546 &lt; 2.2e-16 *** ## log(AdultBodyMass_g) 0.104864 0.019628 5.3426 9.479e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.0261 on 75 degrees of freedom ## Multiple R-squared: 0.2757, Adjusted R-squared: 0.266 ## F-statistic: 28.54 on 1 and 75 DF, p-value: 9.479e-07 0.892 What are the confidence intervals on the maximum likelihood estimate of \\(\\lambda\\). How would you interpret these? # Extract the confidence intervals on lambda pgls.confint(model.pgls, &quot;lambda&quot;)$ci.val ## [1] 0.753434 0.966543 0.753434, 0.966543. We are 95% certain that lambda is between these two values. Plot the \\(\\lambda\\) profile for the the maximum likelihood estimate of \\(\\lambda\\). What does it look like? # Create a likelihood profile of the lambda estimate lambda.profile &lt;- pgls.profile(model.pgls, &quot;lambda&quot;) # Plot the likelihood profile plot(lambda.profile) Is there a significant relationship between log gestation length and log body size? What is the slope of this relationship? # Look at the model outputs. summary(model.pgls) ## ## Call: ## pgls(formula = log(GestationLen_d) ~ log(AdultBodyMass_g), data = primate, ## lambda = &quot;ML&quot;, bounds = list(lambda = c(0.01, 1))) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.097244 -0.019277 -0.001562 0.009037 0.050542 ## ## Branch length transformations: ## ## kappa [Fix] : 1.000 ## lambda [ ML] : 0.892 ## lower bound : 0.010, p = 3.3196e-14 ## upper bound : 1.000, p = 0.00046393 ## 95.0% CI : (0.753, 0.967) ## delta [Fix] : 1.000 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.290229 0.160355 26.7546 &lt; 2.2e-16 *** ## log(AdultBodyMass_g) 0.104864 0.019628 5.3426 9.479e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.0261 on 75 degrees of freedom ## Multiple R-squared: 0.2757, Adjusted R-squared: 0.266 ## F-statistic: 28.54 on 1 and 75 DF, p-value: 9.479e-07 Yes. p &lt; 0.001. Slope = 0.105 \\(\\pm\\) 0.019 12.6 Models of evolution with continuous traits In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit Brownian and OU models to log adult body mass for Primates (AdultBodyMass_g). Then answer the following questions. # Load the packages library(ape) library(geiger) library(treeplyr) library(caper) library(tidyverse) ### Prepare the tree and the data as shown in the Preparation answer above ### ### This should mean you now have mydata and mytree ready to work with ### # Create logBodyMass containing just log body mass values logBodyMass &lt;- log(pull(mydata, AdultBodyMass_g)) # Give log body mass names = species names at the tips of the phylogeny names(logBodyMass) &lt;- mydata$tiplabel # Look at the first few rows head(logBodyMass) ## Cercopithecus_ascanius Cercopithecus_cephus Cercopithecus_mitis ## 8.171950 8.144644 8.525417 ## Cercopithecus_neglectus Cercopithecus_nictitans Erythrocebus_patas ## 8.580078 8.567299 8.982975 # Fit the Brownian model BM &lt;- fitContinuous(mytree, logBodyMass, model = c(&quot;BM&quot;)) # Fit the OU model OU &lt;- fitContinuous(mytree, logBodyMass, model = c(&quot;OU&quot;)) Which model fits best? # Could look at AIC weights... aic.scores &lt;- setNames(c(BM$opt$aic, OU$opt$aic), c(&quot;BM&quot;,&quot;OU&quot;)) aicw(aic.scores) ## fit delta w ## BM 160.1921 0 0.7310586 ## OU 162.1921 2 0.2689414 # Or just the raw AIC values BM$opt$aic ## [1] 160.1921 OU$opt$aic ## [1] 162.1921 BM but only by a small amount What is the rate of evolution for the Brownian model? # Look at the whole output BM ## GEIGER-fitted comparative model of continuous data ## fitted &#39;BM&#39; model parameters: ## sigsq = 0.028655 ## z0 = 6.773956 ## ## model summary: ## log-likelihood = -78.096042 ## AIC = 160.192084 ## AICc = 160.354246 ## free parameters = 2 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 100 ## frequency of best fit = 1.00 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates # Or just the one parameter BM$opt$sigsq ## [1] 0.0286548 0.028655 What is the strength of pull towards the long-term mean in the OU model? What does this value suggest? # Look at the whole output OU ## GEIGER-fitted comparative model of continuous data ## fitted &#39;OU&#39; model parameters: ## alpha = 0.000000 ## sigsq = 0.028655 ## z0 = 6.773956 ## ## model summary: ## log-likelihood = -78.096042 ## AIC = 162.192084 ## AICc = 162.520851 ## free parameters = 3 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 54 ## frequency of best fit = 0.54 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates # Or just the one parameter OU$opt$alpha ## [1] 1.153003e-193 8.080092e-49, i.e. very close to zero which makes it very close to a Brownian model 12.7 Models of evolution with discrete traits In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit equal rates, symmetric rates and all rates different models to the social status variable for Primates (SocialStatus). Note that social status has two states: non-social (1) or social (2). # Load the packages library(ape) library(geiger) library(treeplyr) library(caper) library(tidyverse) ### Prepare the tree and the data as shown in the Preparation answer above ### ### This should mean you now have mydata and mytree ready to work with ### # Create Social containing just social status values Social &lt;- pull(mydata, SocialStatus) # Give social status names = species names at the tips of the phylogeny names(Social) &lt;- mydata$tiplabel # Look at the first few rows head(Social) ## Cercopithecus_ascanius Cercopithecus_cephus Cercopithecus_mitis ## 2 2 2 ## Cercopithecus_neglectus Cercopithecus_nictitans Erythrocebus_patas ## 2 2 2 # Fit the ER model equal &lt;- fitDiscrete(mytree, Social, model = &quot;ER&quot;) # Fit the ARD model ard &lt;- fitDiscrete(mytree, Social, model = &quot;ARD&quot;) Then answer the following questions. Which model fits best? # Using AIC weights aic.scores &lt;- setNames(c(equal$opt$aic, ard$opt$aic), c(&quot;equal&quot;, &quot;different&quot;)) aicw(aic.scores) ## fit delta w ## equal 38.98307 5.313651 0.06556956 ## different 33.66942 0.000000 0.93443044 # Or just the raw AIC values equal$opt$aic ## [1] 38.98307 ard$opt$aic ## [1] 33.66942 All rates different What is the transition rate from non-social (1) to social (2), and vice versa, in the all rates different model? What does this mean biologically? # Could look at the model output ard ## GEIGER-fitted comparative model of discrete data ## fitted Q matrix: ## 1 2 ## 1 -9.264914e-03 9.264914e-03 ## 2 1.476682e-17 -1.476682e-17 ## ## model summary: ## log-likelihood = -14.834711 ## AIC = 33.669423 ## AICc = 33.831585 ## free parameters = 2 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 44 ## frequency of best fit = 0.44 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates # Or plot the Q matrix as network plot.gfit(ard) 1 to 2 is ~0.009, 2 to 1 is very close to zero. Transitions from social (2) to non-social (1) behaviour are extremely rare. Plot ancestral state estimates of social status (from the ARD model) on the phylogeny. Is the root node estimated as being non-social or social? # Ancestral state estimation (ignore the warnings) ancestral_social &lt;- ace(Social, mytree, type = &quot;discrete&quot;, model = &quot;ARD&quot;) ## Warning in sqrt(diag(solve(h))): NaNs produced # Choose colours social_colours &lt;- c(&quot;deeppink&quot;, &quot;goldenrod&quot;) # Plot the tree with colours at the tips and nodes to represent socail status plot(mytree, cex = 0.5, adj = c(0.2), type = &quot;fan&quot;, no.margin = TRUE, show.tip.label = TRUE) tiplabels(pch = 16, col = social_colours[mydata$SocialStatus]) nodelabels(pie = ancestral_social$lik.anc, piecol = social_colours, cex = 0.5) legend(&quot;bottomleft&quot;, pch = 15, bty = &quot;n&quot;, legend = c(&quot;Non Social&quot;, &quot;Social&quot;), col = social_colours) Root is non-social Why didn’t I ask you to fit the symmetric model? Because with only two states the symmetric model is equivalent to the equal rates model 12.8 Beyond simple macroevolutionary models of trait evolution In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Using log body size (AdultBodyMass_g) as your continuous trait, and social status (SocialStatus) to define the selective regimes, fit (A) a multi-rate Brownian motion model and (B) an OU model with trait optima or long-term mean values for different evolutionary regimes but the same \\(\\sigma^2\\) and \\(\\alpha\\). Note that social status has two states: non-social (1) or social (2). Assume it is evolving according to an all rates different model. # Load the packages library(ape) library(geiger) library(treeplyr) library(caper) library(tidyverse) library(OUwie) ### Prepare the tree and the data as shown in the Preparation answer above ### ### This should mean you now have mydata and mytree ready to work with ### # Create Social containing just social status values Social &lt;- pull(mydata, SocialStatus) # Give social status names = species names at the tips of the phylogeny names(Social) &lt;- mydata$tiplabel # Simulate node and tip values for 500 trees using the ARD model trees.ARD &lt;- make.simmap(mytree, Social, model = &quot;ARD&quot;, nsim = 500) ## make.simmap is sampling character histories conditioned on ## the transition matrix ## ## Q = ## 1 2 ## 1 -0.009264911 0.009264911 ## 2 0.000000000 0.000000000 ## (estimated using likelihood); ## and (mean) root node prior probabilities ## pi = ## 1 2 ## 0.5 0.5 # Store the results of the summary of the 500 trees summary.ARD &lt;- summary(trees.ARD) # Get the max likelihood state at each node best &lt;- apply(summary.ARD$ace, 1, which.max) # Assign to the tree node labels mytree$node.label &lt;- levels(as.factor(mydata$SocialStatus))[best] # Make new dataset with just three columns for OUwie bodymass &lt;- data.frame(species = mydata$tiplabel, regime = mydata$SocialStatus, trait = log(mydata$AdultBodyMass_g)) # Fit BMS model BMS &lt;- OUwie(mytree, bodymass, model = &quot;BMS&quot;, root.station = FALSE) ## Warning: An algorithm was not specified. Defaulting to computing the ## determinant and inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. # Fit OUM model OUM &lt;- OUwie(mytree, bodymass, model = &quot;OUM&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the ## determinant and inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Then answer the following questions: Which is the best fitting model? # Extract AICc scores from the models aic.scores &lt;- setNames(c(BMS$AICc, OUM$AICc), c(&quot;BMS&quot;, &quot;OUM&quot;)) # Get aic weights aicw(aic.scores) ## fit delta w ## BMS 161.6226 2.704939 0.205467 ## OUM 158.9176 0.000000 0.794533 OUM If you were running these analyses for a publication, what additional models would you compare these models to? BM and single peak OU for sure. Possibly one or more of the more complex models if you had a good biological reason to In the multi rate Brownian model, which social status state has the higher rate of log body mass evolution? # Look at the model output BMS ## ## Fit ## lnL AIC AICc BIC model ntax ## -77.64691 161.2938 161.6226 168.3252 BMS 77 ## ## Rates ## 1 2 ## alpha NA NA ## sigma.sq 0.04031313 0.0257608 ## ## Optima ## 1 2 ## estimate 6.944823 6.944823 ## se 0.688323 0.688323 ## ## Arrived at a reliable solution Non-social (1) has the higher rate of body mass evolution 0.04031313 Look at the parameter estimates of the multi peak OU model. Do you see anything worrying there? It might help to look at a histogram showing the body sizes of species in the non-social and the social categories. # Look at the output OUM ## ## Fit ## lnL AIC AICc BIC model ntax ## -75.18104 158.3621 158.9176 167.7373 OUM 77 ## ## ## Rates ## 1 2 ## alpha 2.061154e-09 2.061154e-09 ## sigma.sq 2.657014e-02 2.657014e-02 ## ## Optima ## 1 2 ## estimate 5.918899 18607801 ## se 0.679552 7561841 ## ## ## Half life (another way of reporting alpha) ## 1 2 ## 336290887 336290887 ## ## Arrived at a reliable solution # Plot the body sizes for the different groups ggplot(mydata, aes(x = log(AdultBodyMass_g), fill = as.factor(SocialStatus))) + geom_histogram(bins = 20, alpha = 0.5) + scale_fill_manual(values = social_colours) + facet_wrap(~SocialStatus, ncol = 1) + theme(legend.position = &quot;none&quot;) + theme_bw() The optima estimates are way off. Non-social species have a long-term mean log body size estimate of 5.918899, which makes sense looking at the histograms of the data. But social species have a long-term mean log body size estimate of 18607801, which if you exponentiate it is infinity. Even King Kong was not infinitely large! Something has clearly gone wrong here, but if we had not looked at the model parameters we would have said this was the best model…It’s likely we just don’t have enough data to fit a model that is as complex as this, so the parameter optimisations are not reliable. 12.9 Diversification BAMMtools has a several inbuilt example datasets. For this practical exercise we will use the cetacean (whales; from Steeman et al. (2009)) and the ray-finned fishes (fishes; from Rabosky et al. (2013)) datasets. Load the whales and fishes trees and BAMM outputs data into R (there is no mcmc.fishes file_). # Load the packages library(ape) library(BAMMtools) library(coda) library(phytools) library(viridis) # Load whales data from BAMMtools data(whales) data(mcmc.whales) data(events.whales) # Load fishes data from BAMMtools data(fishes) data(mcmc.fishes) ## Warning in data(mcmc.fishes): data set &#39;mcmc.fishes&#39; not found data(events.fishes) # Read in the tree, mcmc, and edata for whales whales_tree &lt;- whales whales_mcmc &lt;- mcmc.whales whales_edata &lt;- getEventData(whales, eventdata = events.whales, burnin = 0.1) ## Processing event data from data.frame ## ## Discarded as burnin: GENERATIONS &lt; 995000 ## Analyzing 1801 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence # Read in the tree, mcmc, and edata for fishes fishes_tree &lt;- fishes fishes_edata &lt;- getEventData(fishes, eventdata = events.fishes, burnin = 0.1) ## Processing event data from data.frame ## ## Discarded as burnin: GENERATIONS &lt; 5 ## Analyzing 46 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence Then answer the following questions: How can we tell that the BAMM model for whales has converged? What is the effective sample size for number of shifts? # Take a look at the plot plot(mcmc$logLik ~ mcmc$generation) # What is 10% of rows? burnstart &lt;- floor(0.1 * nrow(mcmc)) # Remove the first 10% from the runs postburn &lt;- mcmc[burnstart:nrow(mcmc), ] # Extract ESS for the number of rate shifts parameter effectiveSize(postburn$N_shifts) ## var1 ## 273.7424 # Extract ESS for the log likelihood effectiveSize(postburn$logLik) ## var1 ## 219.238 The plot looks like a furry caterpillar (!), and effective sample sizes are well over 200. ESS = 1225.609 What is the most common number of rate shifts in the posterior for the whales data? # Look at the posterior for number of shifts summary(whales_edata) ## ## Analyzed 1801 posterior samples ## Shift posterior distribution: ## ## 0 0.0770 ## 1 0.6600 ## 2 0.2100 ## 3 0.0430 ## 4 0.0110 ## 5 0.0022 ## ## Compute credible set of shift configurations for more information: ## See ?credibleShiftSet and ?getBestShiftConfiguration 1 Plot the 95% credible set of rate shift configurations for whales. # Extract 95% credible set of rate shift configurations whales_css &lt;- credibleShiftSet(whales_edata, expectedNumberOfShifts = 1, threshold = 5, set.limit = 0.95) # Look at the summary summary(whales_css) ## ## 95 % credible set of rate shift configurations sampled with BAMM ## ## Distinct shift configurations in credible set: 4 ## ## Frequency of 4 shift configurations with highest posterior probability: ## ## ## rank probability cumulative Core_shifts ## 1 0.46418656 0.4641866 1 ## 2 0.28928373 0.7534703 1 ## 3 0.14158801 0.8950583 1 ## 4 0.09272626 0.9877846 0 # Plot 95 % credible set of rate shift configurations plot.credibleshiftset(whales_css) ## Omitted 0 plots Plot the mean phylorate plot for fishes. # Plot mean phylorate plot with legend and slighting larger line width (lwd) plot.bammdata(fishes_edata, legend = TRUE, lwd = 2) What are the mean speciation rate and the 90% posterior density for mean speciation rate in fishes? # Extract speciation and extinction rates from the whole posterior allrates &lt;- getCladeRates(fishes_edata) # Calculate overall mean speciation rate mean(allrates$lambda) ## [1] 0.09470252 # Calculate 90% highest posterior density for speciation rate quantile(allrates$lambda, c(0.05, 0.95)) ## 5% 95% ## 0.09020489 0.09960825 Mean = 0.09470252, 5% = 0.09020489, 95% = 0.09960825 References "],["references.html", "References", " References "]]
